<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>割り込み - Rustで始める自作組込みOS入門</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../1_intro/index.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item expanded "><a href="../2_setup/index.html"><strong aria-hidden="true">2.</strong> 環境構築</a></li><li class="chapter-item expanded "><a href="../3_hello/index.html"><strong aria-hidden="true">3.</strong> ベアメタルでHello World</a></li><li class="chapter-item expanded "><a href="../4_interrupt/index.html" class="active"><strong aria-hidden="true">4.</strong> 割り込み</a></li><li class="chapter-item expanded "><a href="../5_process/index.html"><strong aria-hidden="true">5.</strong> プロセス切り替え</a></li><li class="chapter-item expanded "><a href="../6_scheduler/index.html"><strong aria-hidden="true">6.</strong> スケジューラを実装する</a></li><li class="chapter-item expanded affix "><a href="../misc/bib.html">参考文献</a></li><li class="chapter-item expanded affix "><a href="../misc/next_steps.html">この先の開発</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rustで始める自作組込みOS入門</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#割り込み制御" id="割り込み制御">割り込み制御</a></h1>
<p>割り込みはOSをつくる上で重要な項目の1つです。
ペリフェラルが割り込み信号を送ることで、OSは現在の実行処理を中断してペリフェラルからの処理をすることができます。</p>
<p>Armでは現在の実行を中断して非同期に発生するイベントを「例外処理」と呼んでいて、割り込みもその１つです。
今回はSysTickというArmに内蔵されているタイマーモジュールを例として扱ってみようと思います。
SysTickはシステムタイマーといわれていて、OSで一定周期ごとに行う処理などを実装するモジュールです。
このモジュールはARMv7-Mでは必須のモジュールであるため、今回使うNucleoのボード以外のARMv7-Mのボードでも存在するはずです。</p>
<h2><a class="header" href="#armv7-mの例外モデル" id="armv7-mの例外モデル">ARMv7-Mの例外モデル</a></h2>
<p>ARMv7-MのリファレンスマニュアルB1.5章に例外処理の詳細が書かれています。
例外が発生すると、前の章で説明したVector Tableに従って処理が決定されます。
割り込みを含む例外が発生すると、例外に割り振られたIDによってVector Tableに書かれたアドレスにジャンプします。
今回扱うSysTickモジュールではB1.5.2章によると15番の例外が発生します。つまり、Vector Tableの15番目のエントリーとして呼びたい関数をおいておくことになります。</p>
<p>例外が発生した際、後にもとのプログラムの実行に戻るため、プロセッサの状態を一部保存する必要があります。具体的にはArmのレジスタをメモリに退避させることになります。
ここでArmのレジスタについて簡単に説明します。詳しくはB1.4章に書かれています。
ARMv7-MではR0からR15までのレジスタが使用可能です。R0からR12レジスタが汎用レジスタと呼ばれるもので、プログラム中で自由に使うことができます。
R13からR15も算術命令などで使うこともできるのですが、それぞれ特殊な意味を持つレジスタになっています。
R13がスタックポインタ（SP）になっています。現在のスタック領域のメモリアドレスを指すものです。モードによって実は２つのスタックポインタレジスタが使い分けられています。
つまり、プロセッサのモードによって一見アセンブラ命令上は同じSPでも異なるSPを指すことがあるということです。詳しくは次の章で説明します。
R14はリンクレジスタ（LR）です。これは関数の呼び出しをおこなった場合に使われるもので、その関数呼び出しから戻る先のアドレスを保存するためのレジスタです。
R15はプログラムカウンタ（PC)で、現在、実行中の命令のメモリアドレスが格納されているレジスタです。
これ以外のレジスタとしていくつかシステムレジスタが存在しています。これは通常の算術命令などではアクセスできず、特別な命令でしかアクセスできません。
そのうちの１つがプログラムスタータスレジスタ（PSR）というものです。このレジスタは32ビットのレジスタなのですが、用途に合わせて3つのレジスタに分解されるというものです。詳細はここでは割愛します。</p>
<p>例外が発生するとき、ハードウェアがシステムの状態を自動的にスタック領域に退避してくれます。B1.5.6章を見てみましょう。
スタックにはPSR、例外処理が完了したあとに戻るべきアドレス、LR（R14）、R12、R3からR0までが退避されます。また、浮動小数点拡張が有効になっている場合、さらに浮動小数点に関するレジスタも退避されますが、今回は有効にしていないので気にしなくても大丈夫です。
例外処理から復帰する際、これらのスタックに保存されたものが自動的にレジスタに書き戻され、スタックポインタの位置も戻される、という処理もなされます。
しかし、スタック領域に保存されない汎用レジスタが存在することに注意が必要です。これらは通常のプログラムで使用される可能性が十分にあります。
スタックポインタは通常の関数呼び出しをして戻ってくる際に元の値に戻されるはずなので問題ないでしょう。
プログラムカウンタも完了したあと戻るべきアドレスがスタック上に保存されていて、それがプログラムカウンタに書き戻されるのでこれも大丈夫です。
残りのR4からR11のレジスタが使われる可能性があります。しかし、これらのレジスタはArmの関数の呼び出し規約により、関数を呼び出しても関数側で値を戻す必要があるのでこれも保存しなくても大丈夫です。
よって、割り込みハンドラとして関数を呼び出して戻るだけなら、ハードウェア側で必要なレジスタはすべてスタックに保存される、ということになります。</p>
<p>割り込みハンドラ関数から通常の処理に復帰する際にはPCに通常のアドレスではなく、特殊な値を書き戻すことによって通常モードに戻ることができます。
これがB1.5.8で説明されていることです。しかし、B1.5.6章を見ると、割り込みが発生する際、LRの値がもとのモードに戻るように設定されることがわかります。
つまり、特に何もしなくても通常の処理に戻れそうです。</p>
<h2><a class="header" href="#systickの割り込みハンドラを定義する" id="systickの割り込みハンドラを定義する">SysTickの割り込みハンドラを定義する</a></h2>
<p>では、SysTickの割り込みハンドラを定義しましょう。今回は割り込みハンドラの中で特に特別なことはせず、適当な文字列をセミホスティングで表示させるだけにしましょう。
Embedonomiconの4章にあるコードを<code>main.rs</code>に貼り付けてそのまま使ってしまいましょう。</p>
<pre><code>pub union Vector {
    reserved: u32,
    handler: unsafe extern &quot;C&quot; fn(),
}

extern &quot;C&quot; {
    fn NMI();
    fn HardFault();
    fn MemManage();
    fn BusFault();
    fn UsageFault();
    fn SVCall();
    fn PendSV();
    fn SysTick();
}

#[link_section = &quot;.vector_table.exceptions&quot;]
#[no_mangle]
pub static EXCEPTIONS: [Vector; 14] = [
    Vector { handler: NMI },
    Vector { handler: HardFault },
    Vector { handler: MemManage },
    Vector { handler: BusFault },
    Vector {
        handler: UsageFault,
    },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { handler: SVCall },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { handler: PendSV },
    Vector { handler: SysTick },
];

#[no_mangle]
pub extern &quot;C&quot; fn DefaultExceptionHandler() {
    loop {}
}
</code></pre>
<p><code>extern C</code>によってSysTick関数やそれ以外の例外ハンドル用の関数を宣言しています。
これはC言語などで書かれた関数を呼び出すものです。よって、リンクする際にどこかから引っ張ってこなければなりません。
そのため、Embedonomiconでは以下のようなセクションをリンカスクリプトに加えています。</p>
<pre><code>PROVIDE(NMI = DefaultExceptionHandler);
PROVIDE(HardFault = DefaultExceptionHandler);
PROVIDE(MemManage = DefaultExceptionHandler);
PROVIDE(BusFault = DefaultExceptionHandler);
PROVIDE(UsageFault = DefaultExceptionHandler);
PROVIDE(SVCall = DefaultExceptionHandler);
PROVIDE(PendSV = DefaultExceptionHandler);
PROVIDE(SysTick = DefaultExceptionHandler);
</code></pre>
<p>これは、該当する関数が見つからなかった場合、<code>DefaultExceptionHandler</code>を代わりに使うという文になっています。
さらに、<code>EXCEPTIONS</code>を<code>RESET_VECTOR</code>直後に置くため、<code>.vector_table</code>セクションも以下のように書き換える必要があります。</p>
<pre><code>  .vector_table ORIGIN(FLASH) :
  {
    LONG(ORIGIN(RAM) + LENGTH(RAM));

    KEEP(*(.vector_table.reset_vector));

    KEEP(*(.vector_table.exceptions));
  } &gt; FLASH
</code></pre>
<p>これで、とりあえず、ビルドは通りますが、実行しても<code>SysTick</code>関数を定義していないので、ただの無限ループである<code>DefaultExceptionHandler</code>を使うだけなのでなにもわかりません。
そのうえ、まだSysTick割り込みを発生させるためのSysTickモジュールの設定もしていないので、これも行う必要があります。</p>
<p>それではまず、SysTick関数を定義しておきましょう。この関数はあとでリンカスクリプトから参照され、割り込みが発生したときC言語の関数呼び出しのように呼ばれるので、
<code>DefaultExceptionHandler</code>と同様に<code>no_mangle</code>と<code>extern &quot;C&quot;</code>をつけておく必要がある点に注意しましょう。</p>
<pre><code>#[no_mangle]
pub extern &quot;C&quot; fn SysTick() {
    hprintln!(&quot;Systick&quot;).unwrap();
}
</code></pre>
<p>この関数を定義したあと、先程加えた<code>extern &quot;C&quot;</code>で各種例外ハンドル用関数を宣言していたところから<code>SysTick</code>の部分を取り除く必要もあります。</p>
<h2><a class="header" href="#systickモジュールを定義する" id="systickモジュールを定義する">SysTickモジュールを定義する</a></h2>
<p>SysTickの例外ハンドラが定義できたところで、実際のSysTick例外を発生させるところにチャレンジしましょう。
ところで、今まですべての関数をすべて<code>main.rs</code>に書いてきてしまいました。Embedonmiconではいくつかのサブプロジェクトにわけてクレートとして分離する、という方法をとってコードを整理しています。
同じようにクレートとして分離するのも悪くないのですが、今回はお手軽にモジュールという形で分離しましょう。
詳しくは<a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">TPRLの7章</a>が参考になると思います。
このモジュールのシステムは2018 Editionで大きく変更がされているため、個人のブログなどで2015 Editionをベースに解説してる場合があることに注意が必要です。
ただし、後方互換性はあるので、2015 Editionに沿った方法でモジュールを分割しても大きな問題にはなりません。</p>
<p><code>src</code>ディレクトリ以下に<code>systick.rs</code>という以下のような関数を含んだファイルをつくりましょう。</p>
<pre><code>use cortex_m_semihosting::hprintln;

pub fn init() {
    hprintln!(&quot;Systick init&quot;).unwrap();
}
</code></pre>
<p>続いて、<code>main.rs</code>内の<code>Reset</code>関数を以下のように書き換えます。
<code>systick</code>モジュールの宣言と、<code>systick</code>モジュール内の<code>init</code>関数を呼び出しています。</p>
<pre><code>mod systick;

#[no_mangle]
pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    extern &quot;C&quot; {
        static mut _sbss: u8;
        static mut _ebss: u8;
        static mut _sidata: u8;
        static mut _sdata: u8;
        static mut _edata: u8;
    }

    let count = &amp;_ebss as *const u8 as usize - &amp;_sbss as *const u8 as usize;
    ptr::write_bytes(&amp;mut _sbss as *mut u8, 0, count);

    let count = &amp;_edata as *const u8 as usize - &amp;_sdata as *const u8 as usize;
    ptr::copy_nonoverlapping(&amp;_sidata as *const u8, &amp;mut _sdata as *mut u8, count);

    hprintln!(&quot;Hello World&quot;).unwrap();

    systick::init();

    loop {}
}
</code></pre>
<p>ここまでで一度ビルドして実行すると新たに<code>Systick init</code>という文字列が表示されるはずです。
ここからSysTickに関係するコードはこの<code>systick.rs</code>内に書いていき、<code>systick</code>モジュールとして<code>main.rs</code>から使いましょう。</p>
<h2><a class="header" href="#systickのレジスタを設定する" id="systickのレジスタを設定する">SysTickのレジスタを設定する</a></h2>
<p>SysTickを制御するにはSysTickのレジスタを叩いてあげる必要があります。
ArmではこのようなモジュールやペリフェラルのレジスタをメモリマップドIOという形で読み書きします。
プログラム側からは普通のメモリアクセスと同じようにできるという点で便利な仕組みです。
メモリマップドIOとは、このような外部のデバイスのレジスタをメモリアドレスに割り当てて、メモリアクセスのようにレジスタを読み書きする仕組みです。
ただし、これらのレジスタの値の読み書きは本物のメモリとは違って例えば、一部のビットが書き込み不可であるアドレスに書き込んだあとすぐに読み込んだら値が一致しないとか、何も書き込んでいないのに時間が立つと値が変わっている、などの現象が発生します。
そのため、コンパイラが普通のメモリアクセスと同じような最適化をかけてしまうと正しく動作しない場合があります。ここには注意しましょう。</p>
<p>SysTickの詳しい説明はリファレンスマニュアルのB3.3章にまとまっています。
SysTickを使うにはコントロールレジスタ（CSR）、リロードバリューレジスタ（RVR）、カレントバリューレジスタ（CVR）、キャリブレーションバリューレジスタ（CALIB)の3つを触ることになります。
CSRはこのSysTickを有効化させたり、割り込み発生をさせるかどうかの制御などをするためのものです。
CVRは現在のタイマーの値で時間経過とともに値が減っていきます。この値が0になると割り込みを発生させることができます。
0になったあとはRVRで設定された値になります。つまり、RVRの値が割り込みの周期ということになります。
さて、このCVRがどのくらい時間で値が減っていくかですが、CALIBレジスタにその値が記されています。
CALIBには10ミリ秒ごとにどの程度値が減るかの値が設定されるリードオンリーレジスタです。この下位24ビットの値を見てあげれば、RVRやCVRを適切に設定できます。
これらのレジスタがどこにマップされているかもこのリファレンスマニュアルのB3.3.2章に書かれています。</p>
<p>さて、あとはこれらのレジスタを使うだけです。これらのメモリアドレスにアクセスするには標準ライブラリの<code>core::ptr</code>内にある<a href="https://doc.rust-lang.org/core/ptr/fn.read_volatile.html"><code>read_volatile</code></a>と<a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html"><code>write_volatile</code></a>を使います。
volatileというのは揮発性のという意味で、C言語などでは変数の修飾子としてつけることで、その変数へのアクセスの最適化をさせないようにすることができます。
同様に<code>read_volatile</code>や<code>write_volatile</code>も最適化によって変更されてほしくないアクセス、つまり今回のようなメモリマップドIOに使える関数です。
今回は1秒毎に割り込みが発生するように設定してみましょう。<code>systick.rs</code>内の<code>init</code>関数を以下のように書き換えましょう。</p>
<pre><code>use cortex_m_semihosting::hprintln;
use core::ptr::{read_volatile, write_volatile};

const CSR_ADDR: usize = 0xE000_E010;
const RVR_ADDR: usize = 0xE000_E014;
const CVR_ADDR: usize = 0xE000_E018;
const CALIB_ADDR: usize = 0xE000_E01C;

pub fn init() {
    hprintln!(&quot;Systick init&quot;).unwrap();
    unsafe {
        write_volatile(CVR_ADDR as *mut u32, 0);
        let calib_val = read_volatile(CALIB_ADDR as *const u32) &amp; 0x00FF_FFFF;
        write_volatile(RVR_ADDR as *mut u32, calib_val * 100);
        write_volatile(CSR_ADDR as *mut u32, 0x3);
    }
}
</code></pre>
<p><code>read_volative</code>及び<code>write_volatile</code>はともに<code>unsafe</code>な関数なので<code>unsafe</code>ブロックで囲う必要があります。
なお、アドレスを渡す際に<code>usize</code>型をポインタにキャストしている部分がありますが、この操作自体はRustでは安全とされています。
ただし、このアドレスをいざ読み書きする段階になると、この先にあるアドレスがちゃんとしたものになっているかの保証もないですし、ライフタイムのチェックもないので<code>unsafe</code>となるわけです。</p>
<p>さて、これでコンパイルすると、今までのメッセージに加えてSysTickハンドラが1秒毎に呼び出されてメッセージが表示されているはずです。
また、デバッガで動作を止めると、<code>Reset</code>関数自体は最後の無限ループで止まっているのがわかります。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../3_hello/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../5_process/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../3_hello/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../5_process/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
