<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>スケジューラを実装する - Rustで始める自作組込みOS入門</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../1_intro/index.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item expanded "><a href="../2_setup/index.html"><strong aria-hidden="true">2.</strong> 環境構築</a></li><li class="chapter-item expanded "><a href="../3_hello/index.html"><strong aria-hidden="true">3.</strong> ベアメタルでHello World</a></li><li class="chapter-item expanded "><a href="../4_interrupt/index.html"><strong aria-hidden="true">4.</strong> 割り込み</a></li><li class="chapter-item expanded "><a href="../5_process/index.html"><strong aria-hidden="true">5.</strong> プロセス切り替え</a></li><li class="chapter-item expanded "><a href="../6_scheduler/index.html" class="active"><strong aria-hidden="true">6.</strong> スケジューラを実装する</a></li><li class="chapter-item expanded affix "><a href="../misc/bib.html">参考文献</a></li><li class="chapter-item expanded affix "><a href="../misc/next_steps.html">この先の開発</a></li><li class="chapter-item expanded affix "><a href="../misc/history.html">更新履歴</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rustで始める自作組込みOS入門</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#スケジューラを実装する" id="スケジューラを実装する">スケジューラを実装する</a></h1>
<p>前回の章でアプリケーションプロセスへの切り替えを実装しました。
しかし、現状だと再びアプリケーションに突入したり、複数のアプリケーションを動かしたり、といったことができていません。
この章では、簡単なラウンドロビン型のスケジューラを実装して複数のアプリケーションを動かすことを目標としましょう。</p>
<p>スケジューラを実装するには前章まででやってきたアプリケーションプロセスへの切り替えに加えて以下のことが必要です。</p>
<ul>
<li>次に実行可能なプロセスを指すための構造体を実装する</li>
<li>プロセスの状態をメモリ上に保管する構造体とその保存ロジックの実装</li>
</ul>
<p>順番にやっていきましょう</p>
<h2><a class="header" href="#連結リストを実装する" id="連結リストを実装する">連結リストを実装する</a></h2>
<p>スケジューラを実装するに当たって、実行中のプロセスの情報を連結リストの形式で持っておきたいです。
今回実装するスケジューラでは、実行が終わったプロセスを末尾に追加して、先頭から次に実行するプロセスを取ってくるため連結リストを利用したいです。
しかしながら、<code>no_std</code>のプログラミングではお馴染みの動的配列である<code>Vec</code>や<code>LinkedList</code>は使えないので似たような構造体がほしいです。</p>
<p>では、連結リストを<code>linked_list.rs</code>内に実装してみましょう。
C言語などで実装したことがある人がいるとは思いますが、普通はおおよそこんな感じになるでしょう。</p>
<ul>
<li>リスト内に入る各アイテムは、そのアイテムの実際の値と次のアイテムへのポインタを持つ</li>
<li>リスト構造体そのものは先頭要素へのポインタと末尾要素へのポインタを持つ</li>
<li>新しいアイテムを追加するときは現在の末尾要素の次に追加して、リストの持つ末尾要素ポインタを更新</li>
<li>先頭から要素を取り出すには先頭要素ポインタから取り出して、次の要素をリストの持つ先頭要素ポインタに更新</li>
</ul>
<p>Rustでは生ポインタもありますが、通常であればポインタよりも参照を用いた実装が好まれます。
しかし、先程あげたような機能を持つ連結リストは参照では実装は困難です。実際に見てみましょう。</p>
<p>まず、リストそのものと、リストに格納される各要素の定義は以下のような感じになるでしょう。</p>
<pre><code>pub struct ListItem&lt;'a, T&gt; {
    value: T,
    next: Option&lt;&amp;'a mut ListItem&lt;'a, T&gt;&gt;,
}

pub struct LinkedList&lt;'a, T&gt; {
    head: Option&lt;&amp;'a mut ListItem&lt;'a, T&gt;&gt;,
    last: Option&lt;&amp;'a mut ListItem&lt;'a, T&gt;&gt;,
}
</code></pre>
<p>試しに末尾に新しい要素を追加するというメソッドを実装してみましょう。素直に実装するとこんな感じでしょうか。</p>
<pre><code>impl&lt;'a, T&gt; LinkedList&lt;'a, T&gt; {
    pub fn push(&amp;mut self, item: &amp;'a mut ListItem&lt;'a, T&gt;) {
        if self.last.is_none() {
            self.last = Some(item);
            self.head = Some(item);
        } else {
            let prev_last = self.last.replace(item);
            prev_last.map(|i| i.next = Some(item));
        }
    }
}
</code></pre>
<p>しかし、これはコンパイルエラーになります。なぜなら、<code>item</code>はミュータブルな参照なのにもかかわらず、
<code>self.last</code>と<code>self.head</code>ないし1つ手前の<code>ListItem</code>の<code>next</code>の2つのメンバーに保持される必要があります。
ミュータブルな参照は複数存在できないので、このような形では素直には実装できないです。</p>
<p>では、標準ライブラリではどのように実装されているかというと、生ポインタを使うことで解決しています。
確かに生ポインタを使うことは安全ではないのですが、標準ライブラリ内部ではしばしば<code>unsafe</code>な部分が存在しています。
その代わり提供するインターフェスは生ポインタを使うことがないようにして安全でない部分を限定している、というわけです。
そういうことで、ここでは生ポインタを使うことにしましょう。その代わり、このモジュールにはテストを書いておき、きちんとバグがないよう確認しておきましょう。</p>
<p>まず、テストとしては以下のようなものを書いておきましょう。</p>
<pre><code>#[cfg(test)]
mod test {
    use ListItem;
    use LinkedList;

    #[test]
    fn test_list() {
        let mut item1 = ListItem::new(1);
        let mut item2 = ListItem::new(2);
        let mut item3 = ListItem::new(3);
        let mut list = LinkedList::new();

        list.push(&amp;mut item1);
        list.push(&amp;mut item2);
        list.push(&amp;mut item3);

        assert_eq!(Some(&amp;mut 1), list.head_mut());
        let result1: &amp;u32 = list.pop().unwrap();
        assert_eq!(Some(&amp;mut 2), list.head_mut());
        let result2: &amp;u32 = list.pop().unwrap();
        assert_eq!(Some(&amp;mut 3), list.head_mut());
        let result3: &amp;u32 = list.pop().unwrap();
        assert_eq!(1, *result1);
        assert_eq!(2, *result2);
        assert_eq!(3, *result3);

        assert!(list.is_empty());

        let mut item4 = ListItem::new(4);
        let mut item5 = ListItem::new(5);
        list.push(&amp;mut item4);
        list.push(&amp;mut item5);

        let result4: &amp;u32 = list.pop().unwrap();
        let result5: &amp;u32 = list.pop().unwrap();
        assert_eq!(4, *result4);
        assert_eq!(5, *result5);

        assert!(list.is_empty());
    }
}

</code></pre>
<p>最低限のテストではありますが、とりあえず必要なものは見えてきたと思います。</p>
<ul>
<li><code>push</code>：リストの末尾に要素を追加する</li>
<li><code>pop</code>：先頭要素を取り出す。返り値は<code>Option</code>でラップしてリストが空なら<code>None</code>が返る</li>
<li><code>head_mut</code>： 先頭要素のミュータブルな参照を<code>Option</code>でラップして返す。リストそのものは変更しない。</li>
<li><code>is_empty</code>：リストの中に要素が存在するかどうか</li>
</ul>
<p><code>list.pop().unwrap()</code>の結果を<code>&amp;u32</code>として変数に束縛していますが、これは<code>ListItem&lt;'a, T&gt;</code>に対して<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>を実装していることを想定しています。
以降、生ポインタを使っての実際の実装を見せていきますが、ある程度すでにRustに習熟しているのであれば、この仕様を満たすように自力で実装するのもいいでしょう。
以下に示すのはあくまで一例です。また、実装の踏み込んだ解説はあまりしないでおきます。</p>
<p>まずは構造体そのもの定義を変えましょう。参照はすべてポインタに置き換えてしまうのが一番愚直なやりかただと思うので、そうします（もちろん一部を参照を残すこともできます）。</p>
<pre><code>use core::ptr::NonNull;
use core::marker::PhantomData;

pub struct ListItem&lt;'a, T&gt; {
    value: T,
    next: Option&lt;NonNull&lt;ListItem&lt;'a, T&gt;&gt;&gt;,
    marker: PhantomData&lt;&amp;'a ListItem&lt;'a, T&gt;&gt;,
}

pub struct LinkedList&lt;'a, T&gt; {
    head: Option&lt;NonNull&lt;ListItem&lt;'a, T&gt;&gt;&gt;,
    last: Option&lt;NonNull&lt;ListItem&lt;'a, T&gt;&gt;&gt;,
    marker: PhantomData&lt;&amp;'a ListItem&lt;'a, T&gt;&gt;,
}
</code></pre>
<p><a href="https://doc.rust-lang.org/core/ptr/struct.NonNull.html"><code>NonNull</code></a>と<a href="https://doc.rust-lang.org/core/marker/struct.PhantomData.html"><code>PhantomData</code></a>という構造体を使っています。
<code>NonNull</code>はnon-nullでないポインタを意味します。普通の<code>*mut T</code>に対して0ではないという制約がついているわけですが、これにより<code>Option</code>でくくったときに0という値を<code>None</code>として使うようにコンパイルされるため、<code>Option&lt;NonNull&lt;T&gt;&gt;</code>と<code>*mut T</code>のコンパイル後のサイズが同じという利点が生まれます。
すべてをポインタに置き換えてしまうとライフタイムの情報がなくなってしまいます。コンパイル時にこれらの情報を失わないように<code>PhantomData</code>を使ってます。
これはコンパイルされるとサイズが全くないものになるのですが、実際のメンバーのように振る舞うことで型引数をさも要求しているようにコンパイラに見せかけるための構造体です。
詳しくは公式ドキュメントを参照してください。</p>
<p>関数の実装は以下のようにしてみました。</p>
<pre><code>impl&lt;'a, T&gt; ListItem&lt;'a, T&gt; {
    pub fn new(value: T) -&gt; Self {
        ListItem {
            value,
            next: None,
            marker: PhantomData,
        }
    }
}

impl&lt;'a, T&gt; LinkedList&lt;'a, T&gt; {
    pub fn new() -&gt; Self {
        LinkedList {
            head: None,
            last: None,
            marker: PhantomData,
        }
    }

    pub fn push(&amp;mut self, item: &amp;'a mut ListItem&lt;'a, T&gt;) {
        let ptr = unsafe { NonNull::new_unchecked(item as *mut ListItem&lt;T&gt;) };
        let prev_last = self.last.replace(ptr);

        if prev_last.is_none() {
            self.head = Some(ptr);
        } else {
            prev_last.map(|mut i| unsafe {
                i.as_mut().next = Some(ptr);
            });
        }
    }

    pub fn is_empty(&amp;self) -&gt; bool {
        self.head.is_none()
    }

    pub fn head_mut(&amp;mut self)-&gt; Option&lt;&amp;mut T&gt; {
        self.head.map(|ptr| unsafe { &amp;mut *ptr.as_ptr() }.deref_mut())
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;&amp;'a mut ListItem&lt;'a, T&gt;&gt; {
        let result = self.head.take();
        let next = result.and_then(|mut ptr| unsafe {
            ptr.as_mut().next
        });

        if next.is_none() {
            self.last = None;
        }

        self.head = next;

        result.map(|ptr| unsafe { &amp;mut *ptr.as_ptr() })
    }
}
</code></pre>
<p><code>pop</code>の返り値が<code>T</code>の参照でなく<code>ListItem</code>の参照なのは<code>pop</code>で返ってきた構造体を再度リストに追加する、ということができるようにするためです。
<code>push</code>が<code>T</code>でなく<code>ListItem</code>の参照を引数に取っているのは少々美しくないようにも思えます。しかし、現状動的なメモリ確保の方法を実装していません。
そのため、<code>ListItem</code>のためのメモリ領域を確保することができないのでほかから渡してもらう必要があるというわけです。</p>
<p>構造体のメンバーをすべてプライベートにしてしまっているので、<code>ListItem</code>からvalueの値を取り出すことがこのままではできません。
新たなメソッドを追加するのもいいですが、<code>Deref</code>を実装するという方法で実現してみましょう。</p>
<pre><code>use core::ops::{Deref, DerefMut};

impl&lt;'a, T&gt; Deref for ListItem&lt;'a, T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.value
    }
}

impl&lt;'a, T&gt; DerefMut for ListItem&lt;'a, T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.value
    }
}
</code></pre>
<p>ここまで書いたところでテストを走らせたいのですが、このプロジェクト全体が標準ライブラリなしでArmへのクロスコンパイルを前提として書かれていることもあり、このまま<code>cargo test</code>を実行しても正常に動きません。
しかし、このモジュール単体はアーキテクチャへの依存がないため、このプロジェクトは切り離してのテストが可能です。
手軽な方法としては<code>rustc --test</code>でこのファイルのみをテストしてしまうことでしょうか。その際、このファイルの冒頭に<code>#![no_std]</code>をつける必要があります。
ただし、モジュールに本来クレートレベルのアトリビュートである<code>no_std</code>をつけてしまうと、プロジェクト全体をコンパイルしたときに警告が出てしまいます。
他の方法としては、これを別クレートとして新しいプロジェクトに切り出してしまうことです。これならば、その新しくつくったプロジェクト上で<code>cargo test</code>を実行すればいいです。
この方法ならば、コンパイル時の警告もないので、よりまっとうな方法になるでしょう。</p>
<h2><a class="header" href="#プロセスの状態を保存する" id="プロセスの状態を保存する">プロセスの状態を保存する</a></h2>
<p>次にプロセス状態を保存する構造体を定義しましょう。
プロセスの状態としてまず、そのプロセスで使うスタックポインタは保存しなければなりません。
さらに保存しなければならないのは、スタックに退避されないレジスタたちです。</p>
<p>スタックポインタの値はusizeとして、退避されていないレジスタはまとめて<code>u32</code>型の配列として持っておきましょう。</p>
<pre><code>pub struct Process&lt;'a&gt; {
    sp: usize,
    regs: [u32; 8],
    marker: PhantomData&lt;&amp;'a u8&gt;,
}
</code></pre>
<p>プロセスをつくる関数もつくりましょう。スタック用の領域とプロセスの中で実行したい関数を渡したらプロセス構造体が返ってくるとよさそうですね。
その際、スタック領域の初期化処理もしてしまいましょう。</p>
<pre><code>impl&lt;'a&gt; Process&lt;'a&gt; {
    pub fn new(stack: &amp;'a mut [u8], app_main: extern &quot;C&quot; fn() -&gt; !) -&gt; Self {
        let sp = (&amp;stack[0] as *const u8 as usize) + stack.len() - 0x20;
        let context_freame: &amp;mut ContextFrame = unsafe { &amp;mut *(sp as *mut ContextFrame) };
        context_freame.r0 = 0;
        context_freame.r1 = 0;
        context_freame.r2 = 0;
        context_freame.r3 = 0;
        context_freame.r12 = 0;
        context_freame.lr = 0;
        context_freame.return_addr = app_main as u32;
        context_freame.xpsr = 0x0100_0000;

        Process {
            sp: sp as *mut u8,
            regs: [0; 8],
            marker: PhantomData,
        }
    }
}
</code></pre>
<p>このプロセスを実行させるコードも実装しましょう。
プロセスは割り込みが発生すると中断する可能性があります。それを考慮して実装する必要があります。
前章で実装したプロセススタックポインタの書き込みの他に、<code>ContextFrame</code>の中に保存されていないレジスタの書き戻しをする必要があります。
これは中断されたプロセスを再開するためのものです。
また、カーネルに復帰した際、その時点でのプロセススタックポインタと<code>ContextFrame</code>の中に保存されていないレジスタを保存する処理も必要です。</p>
<pre><code>    pub fn exec(&amp;mut self) {
        unsafe {
            llvm_asm!(
                &quot;
                msr psp, r0
                ldmia r1, {r4-r11}
                svc 0
                stmia r1, {r4-r11}
                mrs r0, psp
                &quot;
                :&quot;={r0}&quot;(self.sp)
                :&quot;{r0}&quot;(self.sp), &quot;{r1}&quot;(&amp;self.regs)
                :&quot;r4&quot;, &quot;r5&quot;, &quot;r6&quot;, &quot;r7&quot;, &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;
                :&quot;volatile&quot;
            );
        }
    }
</code></pre>
<p><code>ldmaia</code>と<code>stmia</code>は複数のレジスタの値をまとめてメモリからロード・ストアするための命令です。
スタックポインタ上にレジスタを退避させたりするのに使われます。<code>r1</code>がメモリアドレスになり、この命令後に本来は書き換えられるのですが、
<code>ldmai</code>後に<code>stmia</code>を実行しているので変化した分がすぐに戻されているため、変化が打ち消されているため値の変化はトータルではありません。
<code>mrs</code>が<code>msr</code>の逆でシステムレジスタを読み出すための命令です。</p>
<p>ここまでできたら、前回実装したプロセス切り替え部分のコードをこれらのコードで置き換えてみましょう。
<code>APP_STACK</code>を定義したあとのコードを以下のように書き換えてみましょう。</p>
<pre><code>    #[link_section = &quot;.app_stack&quot;]
    static mut APP_STACK: [u8; 2048] = [0; 2048];

    let mut process = Process::new(&amp;mut APP_STACK, app_main);
    process.exec();

    hprintln!(&quot;Kernel&quot;).unwrap();
</code></pre>
<p>ここまでできたら一度コンパイルしてみて動作確認してみましょう。</p>
<h2><a class="header" href="#スケジューラ本体の実装" id="スケジューラ本体の実装">スケジューラ本体の実装</a></h2>
<p>必要なパーツは全て揃ったところで、これらを組み合わせてスケジューラを実装しましょう。
今回実装するのは登録されたプロセスを順番に実行していくだけのラウンドロビン型のスケジューラです。
なお、プロセスが終了してメモリが開放されることは今回は考えないことにします。
<code>scheduler.rs</code>の中に実装していきましょう。</p>
<p>まず、スケジューラの構造体のメンバーとして保持しておきたいのは実行したいプロセスの連結リストです。</p>
<pre><code>use crate::linked_list::{LinkedList, ListItem};
use crate::process::Process;

pub struct Scheduler&lt;'a&gt; {
    list: LinkedList&lt;'a, Process&lt;'a&gt;&gt;,
}
</code></pre>
<p>実装する関数としては、コンストラクタの他にプロセスの追加関数と、スケジューラ内の関数を実行し続ける関数を実装しましょう。</p>
<pre><code>impl&lt;'a&gt; Scheduler&lt;'a&gt; {
    pub fn new() -&gt; Self {
        Scheduler {
            list: LinkedList::new(),
        }
    }

    pub fn push(&amp;mut self, item: &amp;'a mut ListItem&lt;'a, Process&lt;'a&gt;&gt;) {
        self.list.push(item);
    }

    fn schedule_next(&amp;mut self) {
        let current = self.list.pop().unwrap();
        self.list.push(current);
    }

    pub fn exec(&amp;mut self) -&gt; ! {
        loop {
            let current = self.list.head_mut();
            if current.is_none() {
                unimplemented!();
            }
            current.map(|p| {
                p.exec();
            });
            self.schedule_next();
        }

    }
}
</code></pre>
<p><code>exec</code>が実行用の関数です。リストの先頭要素を実行して、実行が中断されるとリストから一度取り出され、末尾に再度追加されます。
各プロセスが実行を中断するには現状はプロセスが自発的に<code>svc</code>命令を発行するしかありません。
本来であれば、OSが何らかの例外が発生したら切り替えるなどの処理を実装することが多いです（例えばタイマー割り込みで一定時間以上実行していたら切り替える）。が、今回は何もしないことにしましょう。</p>
<p>では、このスケジューラの動作確認のために、簡単なプロセスを３つ用意して、それらをスケジューリングしてみましょう。
まず、各プロセス用の関数ですが、<code>app_main</code>と同じように適当な文字を出力させる関数を追加で２つ用意しましょう。
ただし、プロセスが再開したあとなにもしない無限ループを実行されるとなにもわからなくなるので、文字出力と<code>svc</code>をひたすら繰り返す、というものにしましょう。</p>
<pre><code>extern &quot;C&quot; fn app_main2() -&gt; ! {
    loop {
        hprintln!(&quot;App2&quot;).unwrap();
        unsafe { asm!(&quot;svc 0&quot;::::&quot;volatile&quot;); }
    }
}

extern &quot;C&quot; fn app_main3() -&gt; ! {
    loop {
        hprintln!(&quot;App3&quot;).unwrap();
        unsafe { asm!(&quot;svc 0&quot;::::&quot;volatile&quot;); }
    }
}
</code></pre>
<p>また、<code>app_main</code>も以下のように書き換えましょう。</p>
<pre><code>extern &quot;C&quot; fn app_main() -&gt; ! {
    let mut i = 0;
    loop {
        hprintln!(&quot;App: {}&quot;, i).unwrap();
        unsafe { asm!(&quot;svc 0&quot;::::&quot;volatile&quot;); }
        i += 1;
    }
}
</code></pre>
<p>あとは、<code>Reset</code>関数の末尾を書き換えてスケジューラにプロセス３つを追加しましょう。
まずは、モジュールから使うものを以下のように宣言しておきます。</p>
<pre><code>mod linked_list;
use linked_list::ListItem;
use process::Process;
mod scheduler;
use scheduler::Scheduler;
</code></pre>
<p>あとは、<code>Process</code>を<code>ListItem</code>でラップしたものを3つつくり、これをスケジューラの中に入れて実行するだけです。
なお、<code>Scheduler::exec</code>自身が発散する関数なので、最後の無限ループも取り除くことができます。</p>
<pre><code>    #[link_section = &quot;.app_stack&quot;]
    static mut APP_STACK: [u8; 2048] = [0; 2048];
    #[link_section = &quot;.app_stack&quot;]
    static mut APP_STACK2: [u8; 2048] = [0; 2048];
    #[link_section = &quot;.app_stack&quot;]
    static mut APP_STACK3: [u8; 2048] = [0; 2048];

    let process1 = Process::new(&amp;mut APP_STACK, app_main);
    let mut item1 = ListItem::new(process1);
    let process2 = Process::new(&amp;mut APP_STACK2, app_main2);
    let mut item2 = ListItem::new(process2);
    let process3 = Process::new(&amp;mut APP_STACK3, app_main3);
    let mut item3 = ListItem::new(process3);
    let mut sched = Scheduler::new();
    sched.push(&amp;mut item1);
    sched.push(&amp;mut item2);
    sched.push(&amp;mut item3);

    sched.exec();
}
</code></pre>
<p>こうしてビルドすれば以下のような実行結果が得られるはずです。</p>
<pre><code>Hello World
Systick init
App: 0
App2
App3
App: 1
App2
App3
App: 2
App2
App3
App: 3
App2
...
</code></pre>
<p>なお、Systick割り込みがなかなか表示されないことに気がつくと思いますが、これはSystickのタイマーがデバッグ状態では値が減らないためであり、
デバッグ状態を利用するセミホスティングを利用した出力をたくさんしていると現実の時間が進んでいても、Systickのタイマーが減らないという事態が起きているからです。
試しに<code>hprintln</code>命令を取り除いてあげるとちゃんとSystickが呼び出されるようになるはずです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../5_process/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../misc/bib.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../5_process/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../misc/bib.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
