<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rustで始める自作組込みOS入門</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1_intro/index.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item expanded "><a href="2_setup/index.html"><strong aria-hidden="true">2.</strong> 環境構築</a></li><li class="chapter-item expanded "><a href="3_hello/index.html"><strong aria-hidden="true">3.</strong> ベアメタルでHello World</a></li><li class="chapter-item expanded "><a href="4_interrupt/index.html"><strong aria-hidden="true">4.</strong> 割り込み</a></li><li class="chapter-item expanded "><a href="5_process/index.html"><strong aria-hidden="true">5.</strong> プロセス切り替え</a></li><li class="chapter-item expanded "><a href="6_scheduler/index.html"><strong aria-hidden="true">6.</strong> スケジューラを実装する</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rustで始める自作組込みOS入門</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#はじめに" id="はじめに">はじめに</a></h1>
<p>この本は組込みシステムやOSのような低レイヤーシステムの開発経験がないプログラマーのような人が、自作OSをはじめるため解説本です。
著者自身、本職はウェブプログラマーですが、趣味で組込みOSの自作をしています。この本はそのノウハウ集のようなものです。
このような低レイヤーシステムはC言語で開発されることが多いのですが、今回はRustを使います。
RustはC言語と比較して、様々なモダンな機能やツール郡を取り揃えている上に、C言語の長所である直接のメモリ制御ができ、パフォーマンスも高いとして組込みシステム開発でつかえるとして注目されています。
Rustそのもの解説は控えめですが、低レイヤーシステム開発特有のテクニックは必要に応じて解説します。</p>
<h2><a class="header" href="#想定読者" id="想定読者">想定読者</a></h2>
<p>ある程度はプログラミング経験があり、コンピュータの仕組みを理解していることを前提としています。
Rustに関してですが、基本的な文法事項などは説明しませんが、一通りの文法になんとなく触れている程度の経験があれば十分です。</p>
<p>他の知識・経験、特に組込み開発に関する知識については必要ありません。初歩のマニュアルの読み方・各種ツールの使い方を解説します。</p>
<h2><a class="header" href="#自作組込みosとは" id="自作組込みosとは">自作組込みOSとは</a></h2>
<p>オペレーティングシステム（OS）とはそもそもなんでしょうか。これは自作OSをつくるさいに誰もがぶつかる疑問でしょう。
OSの教科書として有名なMordern Operating Systemの第四版を見てみましょう。</p>
<blockquote>
<p>It is hard to pin down what an operating system is other than saying it is the software that runs in kernel mode--and even that is not true.</p>
</blockquote>
<p>カーネルモードという通常よりも権限の強いCPUのモードで動くソフトウェアとくらいしか定義しようがない、そのうえそれすらも正しくないものかもしれない。と言っています。
その原因のひとつとして、OSには本質的には関係のない２つの機能を持っているからと書かれています。
その２つの機能とは、プログラマーのためにきれいなインターフェースを提供するというものと、ハードウェアのリソースを管理するというものです。</p>
<p>順番に見ていきましょう。まず、インターフェースとしての機能です。CPUや付属するデバイスをそのままの形で直接叩くというのは非常に複雑で難しいです。
例えば、みなさんはプログラミングの一番始めの一歩として「Hello World」などの文字列を出力したと思うのですが、そのとき、「画面に文字を出力する機能」というのは直接実装することはなかったのではないでしょうか？
この「画面に文字を出力する機能」というものを提供しているのはOSです（厳密にはそのOSの機能を利用する言語の標準ライブラリを使うことが多いでしょう）。
このOSがこのような機能を提供してくれるので、例えばモニターを別のメーカーのものや違う規格の接続方法のものに付け替えたとしても、それらの違いというのはOSが吸収してくれる、というわけです。</p>
<p>次に、このようなCPUやデバイスなどを管理するというリソースマネージャーとしての機能です。
パソコンで作業しているときに、作業のためのエディタを立ち上げつつ、BGMを流すための音楽プレーヤーソフトを同じパソコンで立ち上げる、といった複数のアプリケーションを同時に立ち上げるということをすることは多いと思います。
しかし、実際に使えるCPUは限られていて、近年はマルチコアが当たり前になっていますが、その個数を超えてアプリケーションを実行するということも珍しくないと思います。
これを実現しているのがOSのリソースマネージャーとしての機能です。それぞれのアプリケーションに対してCPUをどの程度使っていいかを制限し、CPUで動くアプリケーションを素早く切り替えることによってあたかも複数のアプリケーションが同時に何個も動いているように見せているというわけです。</p>
<h3><a class="header" href="#本書でつくる組込みos" id="本書でつくる組込みos">本書でつくる組込みOS</a></h3>
<p>OSと言われて、多くの人はWindowsやmacOS、Linuxなどの各種デスクトップPC向けのOSや、AndroidやiOSのようなスマートフォン向けのOSを思い浮かべると思います。
しかし、実際には様々な家電製品やセンサーノードなどの小さな電子機器にも組込みOSと言われるOSが入っていることが多くあります。他のWindowsなどのOSは汎用OSと言われます。
組込みOSは小型な機器にも使えるように汎用OSとは異なる設計になっていて以下のような傾向があります。</p>
<ul>
<li>使える機能が汎用OSに比べると少ない</li>
<li>リアルタイム性、つまり一定周期毎、あるいは特定のイベントに対して遅れることなくタスクを実行することが重視される</li>
<li>メモリやCPU性能を多くは使わない</li>
</ul>
<p>もっとも汎用OSと組込みOSの厳密な区別はなく、最近は強力な組込み機器向けのCPUも多く存在するため、Linuxが組込み機器に使われるケースもあります。
そのため、必ずしも上記のような性質が常に当てはまるわけではなく、汎用OSと大差がないという場合もあります。</p>
<p>今回、自作しようとしている組込みOSはArmのCortex-MというCPUを対象としたものです。
Armはスマートフォンやゲーム機にも使われていますが、こちらはCortex-AというCPUがメインです。
Cortex-MはAよりも低価格・省電力なのが特徴です。その分、性能面や使えるメモリが少ないです。
どういうところに使われるかというと、ネットワークにつながるセンサーやモーターなどの制御です。</p>
<p>今回作ろうとするOSは例えば画面の上にきれいな画像を出すとかマウスやキーボードの操作を受け付ける、というものではありません。
CPUそのものがそういう用途ではないからです。</p>
<p>最終的につくるのは、簡単なスケジューラと割り込み制御を備えた非常に簡易なOSです。
先程上げたOSとしての２つの機能のうち、後者の側面がつよいものになっています。
そのため、完成形は少し物足りないものになっているかもしれません。
しかしながら、自作OSでは最初の一歩が非常にハードルが高いと思うので、その最初の一歩を助けるという意識で書きました。</p>
<h2><a class="header" href="#フィードバック" id="フィードバック">フィードバック</a></h2>
<p>本書は<a href="https://github.com/garasubo/embedded-book">こちらのGithubレポジトリ</a>で更新しています。
もし、何か誤字脱字や誤りがあった場合は、このレポジトリのissueとして報告していただけると助かります。
それ以外にももっとここを説明してほしいといった要望でも構いません。</p>
<p>その他、筆者の<a href="https://twitter.com/garasubo">Twitter</a>でも各種フィードバックを受け付けています。</p>
<h1><a class="header" href="#環境構築" id="環境構築">環境構築</a></h1>
<p>筆者はUbuntu 18.04で動作確認をしていますが、基本的にはWindowsやMac環境でも構築可能です。</p>
<h2><a class="header" href="#rust" id="rust">Rust</a></h2>
<p><code>rustup</code>を使う方法が公式でも全プラットフォーム共通で推薦されているので、これに従います。
[https://rustup.rs/]の方法に従って、rustupをインストールします。LinuxやMacのようなUnixライクなOSの場合、以下のようにインストールします。</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>rustupはRustコンパイラのインストール・アップデートやバージョン管理をしてくれるツールです。
今回は特に<code>nightly</code>と呼ばれる、いわゆるベータ版のようなRustコンパイラを使うことになるのですが、nightlyと安定版である<code>stable</code>の切り替えもコマンド一つで行えて大変便利です。</p>
<p>今回はnightlyの2019-09-19のバージョンを使います。以下のようにして<code>nightly-2019-09-18</code>をインストールしましょう。</p>
<pre><code>$ rustup install nightly-2019-09-18
</code></pre>
<p>さらにArmのクロスコンパイル用の環境を入れるために以下のコマンドを実行します</p>
<pre><code>$ rustup target add thumbv7em-none-eabihf
</code></pre>
<h2><a class="header" href="#使用ボード" id="使用ボード">使用ボード</a></h2>
<p>STマイクロエレクトロニクス社の<a href="https://www.st.com/ja/evaluation-tools/nucleo-f429zi.html">NUCLEO-F429ZIボード</a>を使用します。
ただし、この本では多くのペリフェラルは使わないので、ST社のCortex-Mの他のボードでも十分に再現可能かと思われます。</p>
<h2><a class="header" href="#仕様書ドキュメント" id="仕様書ドキュメント">仕様書・ドキュメント</a></h2>
<h3><a class="header" href="#ハードウェア関連" id="ハードウェア関連">ハードウェア関連</a></h3>
<p>低レイヤーシステムは仕様書をちゃんと読み理解する、ということがとても重要になります。
マイコンボードの種類によっては、仕様書を手に入れるためには面倒な契約を結ぶ必要があるケースもありますが、今回使うNucleoボード及びそのCPUの仕様書はすべてオンラインで入手可能です。
この本では、実際に仕様書を参照しつつ、OSを書いていきますのでこれらもダウンロードしてください。
なお、以下のリンクにある仕様書は基本的に英語版です。日本語版もある場合がありますが、最新版ではないため英語版を参照するほうが安全です。</p>
<ul>
<li>
<p><a href="https://developer.arm.com/docs/ddi0403/ed/armv7-m-architecture-reference-manual">Arm®v7-M Architecture Reference Manual</a>
ボードに乗っているCPUの基本的な仕様書です。アセンブラ命令の解説や、割り込みが発生したときの挙動、システムレジスタの仕様などが書かれています。</p>
</li>
<li>
<p><a href="https://developer.arm.com/docs/100166/0001">ARM Cortex-M4 Processor Technical Reference Manual Revision r0p1 Documentation</a>
Arm v7-Mの仕様に基づいたアーキテクチャであるCortex-M4のマニュアルです。<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0439cj/index.html">日本語版</a>も多少古いバージョンですが存在します。
割り込みコントローラやメモリ保護機構などの解説があります。また、Arm v7-Mについても簡単な説明があります。</p>
</li>
<li>
<p><a href="https://www.stmcu.jp/design/document/reference_manual/51544/">STM32F42xxxのリファレンスマニュアル</a>
今回使うボードのCPUのペリフェラル（周辺機器）の仕様書です。例えばLEDを光らせるにはGPIOというペリフェラルから信号を送るのですが、そういうものの使い方が知りたい場合はこのマニュアルを基本的に読むことになります。</p>
</li>
<li>
<p><a href="https://www.st.com/resource/en/datasheet/stm32f429zi.pdf">STM32F429xxのデータシート</a>
CPUについての詳細です。CPUの仕様はリファレンスマニュアルだけでなく、こちらのデータシートも併せて読むことになります。</p>
</li>
<li>
<p><a href="https://www.st.com/content/st_com/ja/products/evaluation-tools/product-evaluation-tools/mcu-mpu-eval-tools/stm32-mcu-mpu-eval-tools/stm32-nucleo-boards/nucleo-f429zi.html">Nucleo-144ボードのユーザーマニュアル</a>
ボードそのものについてのドキュメントです。どの端子やピンがどうCPUに結びついているかなどの使い方を調べるために使います。</p>
</li>
</ul>
<h3><a class="header" href="#rust関連" id="rust関連">Rust関連</a></h3>
<p>Rustそのものについてのドキュメントもしっかりと見ていく必要があります。
まず、Rustに関する知識が一切ない場合、TRPLと呼ばれるチュートリアルを一通り眺めてみるのが良いでしょう。</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a></li>
<li><a href="https://doc.rust-jp.rs/book/second-edition/">日本語版</a>
本書ではRustに関する初歩的な構文の知識などには触れないため、もしわからないことがあればこちらを参照してください。</li>
</ul>
<p>低レイヤーのプログラミングを行うにあたって、Rustの詳細な実装を知る必要がある場面があります。
そのための本としてThe Rustonomiconというのがあります。</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/index.html">Ther Rustonomicon</a>
こちらは必要になったら参照することになりますが、すべてを理解しておく必要はありません（正直なところ筆者もすべての項目を把握していないです）。</li>
</ul>
<h1><a class="header" href="#ベアメタルでhello-world" id="ベアメタルでhello-world">ベアメタルでHello World</a></h1>
<p>この章の内容は<a href="https://docs.rust-embedded.org/embedonomicon/preface.html">The Embednomicon</a>にちょっと詳しい解説をつけただけです。すでにこちらのドキュメントを読んでいるのであればこの章は飛ばして次の章に進んでください。</p>
<h2><a class="header" href="#プロジェクトのセットアップ" id="プロジェクトのセットアップ">プロジェクトのセットアップ</a></h2>
<p><code>rustup</code>でRustコマンドをインストールすると<code>cargo</code>というコマンドが使えるようになります。
このコマンドはRust標準のビルドシステム兼パッケージマネージャーです。</p>
<p>まずはOS用の新規プロジェクトをつくりましょう。今回のプロジェクト名は<code>bookos</code>で行きます。もし自分の気に入ったプロジェクト名があれば、それでも構いません。</p>
<pre><code>$ cargo new bookos
     Created binary (application) `bookos` package
$ cd bookos
$ ls
Cargo.toml  src
$ ls src
main.rs
</code></pre>
<p><code>src/main.rs</code>をこれから書き換えてHello Worldするプログラムを書いていきます。
その前に、このプロジェクトで使うRustのバージョンを指定するために<code>rust-toolchain</code>というファイルをこのプロジェクトにおいておきます。</p>
<pre><code>$ echo &quot;nightly-2019-09-19&quot; &gt; rust-toolchain
</code></pre>
<p>このファイルがプロジェクトのトップディレクトリにあることで、rustupにどのバージョンのRustを使えばいいかを自動的に教えて、バージョンを切り替えてくれるようになります。</p>
<h2><a class="header" href="#プログラムの実行" id="プログラムの実行">プログラムの実行</a></h2>
<p>OSのある環境下では、たとえばターミナルから実行コマンドを打つことでOSがプログラムをロードして実行してくれますが、
OSのないベアメタル環境ではどのように自分の実行したいプログラムを実行すればいいのでしょうか？
電源投入時のCPUの動作について、ARMv7-MのアーキテクチャリファレンスマニュアルのB1.5.5　Reset behaviorに書いてあります。
この疑似コードによると、最後に<code>tmp</code>と<code>0xFFFF_FFFE</code>のandを取った値にブランチする、つまり<code>tmp</code>の値の最下位ビットを0にしたメモリアドレス上に置かれたプログラムが実行される、ということのようです。
この<code>tmp</code>は<code>vectortable</code>+4の値になるようですが、この<code>vectortable</code>の説明はB1.5.3にあります。Vector tableは例外が発生したときにどのアドレスにジャンプするべきかを指す配列です。
先頭エントリーはリセット時のスタックポインタの値になるので、4バイト先のエントリがリセット時に飛ぶべきアドレスとなっています。
このvector tableですが、どこに置かれるべきかはチップの実装依存となっているため、今回はSTM32F42xxxのリファレンスマニュアルを見る必要があります。
2.4 Boot configurationの章を見てみましょう。本来であれば0番地がコードの最初のエリアになるのですが、設定によってこれを変更できることが書いてあります。
<code>BOOT0</code>と<code>BOOT1</code>の値で制御されるのですが、Nucleoボードのユーザーマニュアルによるとどうやらデフォルト値はともに0のようなので、メインのフラッシュメモリから読み出されることになります。
このフラッシュメモリのアドレスはというとSTMのリファレンスマニュアル3.4章の表に<code>0x800_0000</code>番地から始まる、と書いてあるので、ここにvector tableを配置してあげれば自分のプログラムを実行できるということになりそうです。
このフラッシュメモリ領域がいわゆるROMの領域で、ここに自分のプログラムを書き込んであげることになります。</p>
<h2><a class="header" href="#no_std環境下でのrust" id="no_std環境下でのrust">no_std環境下でのRust</a></h2>
<p>自分のプログラムをボード上で実行させる方法がなんとなくわかったと思いますが、問題はどうやったらこのフォーマットに従ったプログラムをRustで書いてバイナリにすればいいか、です。
それを解説したのがThe Embednomiconだったわけです。</p>
<p>通常、Rustのプログラムを書くときstdクーレートと呼ばれる言語の標準ライブラリを利用してプログラムをコンパイルすることになります。
しかし、このstdクレートは様々なOSの機能を利用することを前提として実装されているので、OSのないベアメタル環境下では当然動きません。
また、コンパイルしたときのフォーマットもOS上で実行するためのフォーマットになっているので、それも変更しなければなりません。
前者の問題を解決するための手段が<code>#![no_std]</code>アトリビュートです。これを使うとstdクレートの代わりに、OSの存在なしでも利用できる機能を提供する<code>core</code>クレートを使ってプログラムをコンパイルしてくれます。</p>
<p>では、no_stdでの最小プログラムをThe Embednomiconから引用します。</p>
<pre><code>#![no_main]
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo&lt;'_&gt;) -&gt; ! {
    loop {}
}
</code></pre>
<p><code>#![no_main]</code>というアトリビュートがついていて、main関数がないこと、<code>#[panic_handler]</code>というアトリビュートがついた<code>panic</code>関数が存在することが普通のプログラムとは異なっています。
<code>main</code>関数が通常であれば最初に実行されるプログラムとなるのですが、これもOSが存在して事前準備をしてくれることを前提としたものになっています。
<code>main</code>関数に相当するレイヤーは後々つくっていくことになりますが、今回は最小の、なので省略です。
代わりにパニック時の動作についてはきちんと指定する必要があります。例えば<code>Option</code>の<code>None</code>に対して<code>unwrap</code>を呼び出すと通常のプログラムならば異常終了するはずですが、OSのないベアメタル環境ではこの異常終了時の動作を定義してあげる必要があります。
これが<code>#![panic_handler]</code>アトリビュートがついている<code>panic</code>関数、というわけです。今回は単に無限ループさせるだけですね。</p>
<p>このプログラムをビルドしてみましょう。
普通にビルドしてしまうと、実行しているPC向けのバイナリをつくってしまいますので、ターゲットを指定してあげる必要があります。</p>
<pre><code>$ cargo build --target thumbv7em-none-eabihf
   Compiling bookos v0.1.0 (/home/garasubo/workspace/bookos)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
</code></pre>
<p><code>thumb</code>というのはArmの命令セットの名前で、命令長が16ビットになっているという特徴があります。ARM命令と呼ばれる命令セットも存在してそちらは命令長が32ビットなのですが、ARMv7-Mではこちらはサポートされていません。
後ろの<code>hf</code>というのはハードウェアの浮動小数点演算器が存在することを示しています。一部のARMv7-Mのチップでは浮動小数点演算器がないことがあり、コンパイラでそれらをソフトウェア演算にしなければならないことがあります。
もっとも、今回は浮動小数点の絡む処理を書く予定はないので、間違えてつけなくても（あるいは違うボードを使っていて浮動小数点演算器がないにもかかわらず<code>hf</code>をつけたとしても）問題にはならないでしょう。</p>
<h2><a class="header" href="#vector-tableを定義する" id="vector-tableを定義する">Vector tableを定義する</a></h2>
<p>stdが使えない問題はクリアしましたが、まだなにもプログラムが実行できない状態なのでこれを解決していきましょう。
このArmマイコンではVector tableに従って最初に実行されるプログラムが決定されることがマニュアルからわかっているので、このVector tableを組み込んだプログラムをコンパイルできるようにすればこの問題は解決できます。
プログラムをコンパイルしたとき、各関数や変数がどのようなフォーマットでバイナリとして配置されるかを定義するにはリンカースクリプトというものを使います。
これはC言語など他の言語でベアメタルプログラミングするときも使うものです。
The Embednomiconの2.Memory layoutの章で使われているリンカースクリプトを見てみましょう。このリンカスクリプトは<code>link.ld</code>としてプロジェクトのトップディレクトリにおいておきましょう。</p>
<pre><code>* Memory layout of the LM3S6965 microcontroller */
/* 1K = 1 KiBi = 1024 bytes */
MEMORY
{
  FLASH : ORIGIN = 0x00000000, LENGTH = 256K
  RAM : ORIGIN = 0x20000000, LENGTH = 64K
}

/* The entry point is the reset handler */
ENTRY(Reset);

EXTERN(RESET_VECTOR);

SECTIONS
{
  .vector_table ORIGIN(FLASH) :
  {
    /* First entry: initial Stack Pointer value */
    LONG(ORIGIN(RAM) + LENGTH(RAM));

    /* Second entry: reset vector */
    KEEP(*(.vector_table.reset_vector));
  } &gt; FLASH

  .text :
  {
    *(.text .text.*);
  } &gt; FLASH

  /DISCARD/ :
  {
    *(.ARM.exidx .ARM.exidx.*);
  }
}
</code></pre>
<p><code>MEMORY</code>というのがマイコンのメモリのレイアウトを記述するセクションになっていて、<code>SECTIONS</code>でプログラムをそのメモリにどう配置するかを定義しています。
<code>MEMORY</code>の中身はハードウェア依存で、本書で使っているマイコンのレイアウトとは異なるので、あとで修正する必要があります。
<code>.vector_table</code>というのがVector tableを配置するところです。<code>FLASH</code>の先頭に置くようにしています。
一番最初のエントリーはスタックポインタのアドレスの初期値を格納する必要があります。
次のエントリーはリセット時に呼び出される関数へのアドレスになっています。これをRust側で定義してあげればいいというわけですね。
このスクリプトではRAM領域の末尾を指定してます。スタックポインタは末尾から先頭に向かって伸びていくので、通常は利用可能なRAM領域の末尾をしてしておけばよいでしょう。
<code>.text</code>セクションが実際のプログラムを置く場所です。
<code>.ARM.exidx</code>は標準ライブラリでのみ利用するセクションなので破棄するように指示しています。</p>
<p>では、<code>reset_vector</code>を定義してあげるところを引用します。</p>
<pre><code>// The reset vector, a pointer into the reset handler
#[link_section = &quot;.vector_table.reset_vector&quot;]
#[no_mangle]
pub static RESET_VECTOR: unsafe extern &quot;C&quot; fn() -&gt; ! = Reset;
</code></pre>
<p><code>#[link_section = &quot;.vector_table.reset_vector&quot;]</code>というアトリビュートで、メモリ上の配置をしてあげることができます。
<code>RESET_VECTOR</code>という変数をそこにおいてあげるというわけですが、これが<code>Reset</code>関数への関数ポインタになっています。
<code>extern &quot;C&quot;</code>というのがついていると思いますが、これはC言語の関数と同じ形式で呼び出せるようにするというものです。
関数の型ですが、<code>() -&gt; !</code>となっています。この返り値の<code>!</code>というのはこの関数を実行したら決して終了することはない、ということを意味しています。
C言語の関数とRustの関数はコンパイルしたときにフォーマットが異なり、C言語形式でないとマイコンはそこにジャンプしてそのまま実行ということができません。
<code>#[no_mangle]</code>というアトリビュートもついています。Rustでコンパイルしたとき、変数や関数の名前はリンカースクリプト内では別の名前（シンボル）に置き換えられるマングリングという処理が行われます。これを防ぐのがこのアトリビュートの役割です。
しかし、今回はこの変数を直接指定するということをしていないので、なくても動くでしょう。</p>
<p>あとは<code>Reset</code>関数を定義すれば完成です。</p>
<pre><code>#[no_mangle]
pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    let _x = 42;

    // can't return so we go into an infinite loop here
    loop {}
}
</code></pre>
<p>さて、上述のリンカスクリプトを使うためには、コンパイル時にオプションとして渡してあげる必要があります。
<code>RUSTFLAGS</code>を環境変数としてセットすることで、<code>rustc</code>コマンドにオプションを追加することができます。</p>
<pre><code>$ RUSTFLAGS=&quot;-C link-args=-Tlink.ld&quot; cargo build --target thumbv7em-none-eabihf
   Compiling bookos v0.1.0 (/home/garasubo/workspace/bookos)
    Finished dev [unoptimized + debuginfo] target(s) in 0.15s
</code></pre>
<p>さて、毎回このオプションを渡すのは少々面倒くさいです。<code>.cargo/config</code>というファイルをつくっておくと、デフォルトのパラメータをセットできます。詳しくは<a href="https://doc.rust-lang.org/cargo/reference/config.html">公式のドキュメント</a>を参照してください。</p>
<pre><code>[target.thumbv7em-none-eabihf]
rustflags = [
    &quot;-C&quot;, &quot;link-arg=-Tlink.ld&quot;,
]

[build]
target = &quot;thumbv7em-none-eabihf&quot;
</code></pre>
<p>こうしておけば単に<code>cargo build</code>とすれば前の様々なオプションをつけたコマンドと同じ結果が得られるはずです。</p>
<h2><a class="header" href="#プログラムをボードで実行する" id="プログラムをボードで実行する">プログラムをボードで実行する</a></h2>
<p>ここで一度ボードにプログラムを書き込んであげたいと思います。
まずは、<code>link.ld</code>の中のアドレスを修正するところから始めます。STMのリファレンスマニュアルの3.4章によるとFLASHの領域は<code>0x800_0000</code>から<code>0x81f_ffff</code>までの2MB領域に広がっていることがわかります。
RAM領域はリファレンスマニュアルの2.3.1を見ると<code>0x2000_0000</code>から256KBの領域にあるとわかります。
しかし、STMのデータシートの方を3.6章を見ると、64KBはcore coupled memoryで使うことができず、5章のメモリマップを見ると<code>0x2003_0000</code>以降の領域は使えないことがわかります。
よって、以下のように書き換えましょう。</p>
<pre><code>MEMORY
{
  FLASH : ORIGIN = 0x08000000, LENGTH = 2M
  RAM : ORIGIN = 0x20000000, LENGTH = 192K
}
</code></pre>
<p>書き換えたら再度<code>cargo build</code>しましょう。</p>
<p>プログラムをフラッシュROMに書き込むにはST-Linkというこのボードに内蔵されたデバッグ用インターフェースを利用することで可能です。
ボードには2つmicro USBの端子がついていると思いますが、切れ込みで別れた小さいエリアについている方の端子（CN1）がST-Linkと通信するための端子です。
PC側はこのインターフェースを利用するために<a href="http://openocd.org/">Open OCD</a>を使います。Ubuntuであれば<code>apt</code>コマンド経由でインストールできます。</p>
<pre><code>IMAGE=target/thumbv7em-none-eabihf/debug/bookos openocd -f interface/stlink-v2-1.cfg -f target/stm32f4x.cfg -c &quot;init; reset halt; flash write_image erase $IMAGE; verify_image $IMAGE; reset; shutdown&quot;
</code></pre>
<p><code>-f</code>オプションでデフォルトで用意された設定ファイルを利用することができます。<code>-c</code>オプションでコマンドを実行しています。このコマンドでボードを初期化した後、<code>$IMAGE</code>で指定されたファイルを書き込んだ後、ちゃんと書き込めたかの確認もしています。
<code>cargo build</code>で生成されたバイナリは<code>target/&lt;アーキテクチャ名&gt;/debug/&lt;アプリケーション名&gt;</code>にあります。
しかし、もとのプログラムが無限ループするだけで何もしていないプログラムのため、これでは動いているかどうかすらよくわかりません。
そこで、デバッガを利用することでどのようにプログラムが動いているか覗いてみましょう。デバッガは<code>GDB</code>を利用します。
Ubuntu 18.04以降では<code>apt</code>より<code>gdb-multiarch</code>を、それ以前の場合は<code>gdb-arm-none-eabi</code>をインストールしましょう。
GDBには別の環境で動いているプログラムと通信してデバッグする機能があります。Open OCDはGDBと通信するためのサーバーとしての機能もあります。
ターミナルを2つ開いて、片方のターミナルでは</p>
<pre><code>openocd -f interface/stlink-v2-1.cfg -f target/stm32f4x.cfg
</code></pre>
<p>を実行しておくとこれがGDBのサーバーとなります。
別のターミナルで</p>
<pre><code>gdb-multiarch target/thumbv7em-none-eabihf/debug/bookos
</code></pre>
<p>を実行するとGDBが立ち上がりますが、この状態ではまだサーバーとは通信していません。<code>target remote</code>コマンドでサーバーを指定したのち、プログラムを読み込んでみましょう。</p>
<pre><code>(gdb) target remote :3333
Remote debugging using :3333
0x00000000 in ?? ()
(gdb) load
Loading section .vector_table, size 0x4 lma 0x8000000
Start address 0x0, load size 4
Transfer rate: 7 bytes/sec, 4 bytes/write.
(gdb) break Reset
Breakpoint 1 at 0x800000c: file src/main.rs, line 13.
</code></pre>
<p>これでReset関数にブレークポイントが仕掛けられました。
あとは普通にステップ実行できます。</p>
<pre><code>(gdb) continue
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, Reset () at src/main.rs:13
13	    let _x = 42;
(gdb) step
16	    loop {}
(gdb) 
^C
Program received signal SIGINT, Interrupt.
0xe7ff9000 in ?? ()
</code></pre>
<p>最後は無限ループになっているので、強制的に止めました。</p>
<h2><a class="header" href="#いざhello-world" id="いざhello-world">いざ、Hello World</a></h2>
<p>プログラムは書き込めたのでHello Worldを出力していきたいと思います。
しかし、今回のボードにはディスプレイはついていません。どこにこの文字を出力すればいいのでしょうか。
一般的に、このような組込みボードと通信するインターフェースとしてUARTというモジュールがあります。これを使えばPCとマイコン間で比較的簡単に通信ができます。
しかし、今回はこれを使わずもっと手軽なセミホスティングというデバッガを介した出力でこれをやろうと思います。
この方法はあくまでデバッグ用の機能なので、デバッガをつけられない実際の製品版で用いることはできず、UARTと比べるとかなり通信速度は遅いのですが、
今回の目的はあくまでプログラムがちゃんと動作しているかの確認のためのHello Worldなので、セミホスティングを使うことにしましょう。
このセミホスティングの機能を全部理解するのも大変なので、今回は既存のライブラリを使ってしまいましょう。
RustのEmbeddedワーキンググループの提供しているクレートである<code>cortex-m-semihosting</code>を使います。
<code>Cargo.toml</code>の<code>dependency</code>としてこのクレートを追加します。</p>
<pre><code>[dependencies]
cortex-m-semihosting = &quot;0.3.5&quot;
</code></pre>
<p>その後、<code>src/main.rs</code>内のReset関数を以下のように書き換えます。</p>
<pre><code>use cortex_m_semihosting::hprintln;

#[no_mangle]
pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    hprintln!(&quot;Hello World&quot;).unwrap();

    loop {}
}
</code></pre>
<p>これでビルドをしてみると、リンクのところで失敗してしまいます。</p>
<pre><code>$ cargo build
...
  = note: rust-lld: error: no memory region specified for section '.rodata'
          rust-lld: error: no memory region specified for section '.bss'
          

error: aborting due to previous error

error: Could not compile `bookos`.

To learn more, run the command again with --verbose.
</code></pre>
<p><code>.rodata</code>と<code>.bss</code>セクションがないと言われています。ざっくり説明すると<code>.rodata</code>は定数を保存しておく領域、<code>.bss</code>は初期値が0のグローバル変数を保存する領域です。
これ以外にも<code>.data</code>という初期値が0でないグローバル変数のための領域も実は定義をサボってきました。
これらのセクションはリンカースクリプトで定義しないといけないのはもちろんなのですが、これをちゃんとプログラムで使うためにはいくつか処理をする必要があります。
<code>.bss</code>セクションは書き換えの必要があるため、RAM領域に配置されるのですが、RAM領域の初期値が0である保証はないのでこれを0にプログラム側で初期化してあげる必要があります。
<code>.data</code>セクションは初期値がROM領域にあって実際の変数はRAM領域に配置されることになるので、ROM領域の初期値をRAM領域側にコピーする必要があります。
<code>.rodata</code>はリードオンリーなので何もしなくて大丈夫です。
Embedonomiconと同様にReset関数の先頭で以下のような処理をしておきましょう。</p>
<pre><code>use core::ptr;

pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    extern &quot;C&quot; {
        static mut _sbss: u8;
        static mut _ebss: u8;
        static mut _sidata: u8;
        static mut _sdata: u8;
        static mut _edata: u8;
    }

    let count = &amp;_ebss as *const u8 as usize - &amp;_sbss as *const u8 as usize;
    ptr::write_bytes(&amp;mut _sbss as *mut u8, 0, count);

    let count = &amp;_edata as *const u8 as usize - &amp;_sdata as *const u8 as usize;
    ptr::copy_nonoverlapping(&amp;_sidata as *const u8, &amp;mut _sdata as *mut u8, count);
...
</code></pre>
<p><code>link.ld</code>は以下のようなセクションを加えます。</p>
<pre><code>SECTIONS
{
...

  .rodata :
  {
      *(.rodata .rodata.*);
  } &gt; FLASH

  .bss (NOLOAD):
  {
    _sbss = .;
    *(.bss .bss.*);
    _ebss = .;
  } &gt; RAM

  .data : AT(ADDR(.rodata) + SIZEOF(.rodata))
  {
    _sdata = .;
    *(.data .data.*);
    _edata = .;
  } &gt; RAM

  _sidata = LOADADDR(.data);

  /DISCARD/ :
...

</code></pre>
<p>link.ldで定義した定数をReset関数で<code>extern C</code>で読み込んで使っています。
まず<code>_sbss</code>から<code>_ebss</code>の領域を<code>ptr::write_bytes</code>で0で初期化します。
次に<code>.data</code>の初期値は<code>_sidata</code>の値から始まるROM領域に存在しますがROM領域にはプログラムでは書き換え不能なので、プログラム上の配置は<code>_sdata</code>から始まるRAM領域になっています。
これを<code>ptr::copy_nonoverlapping</code>でコピーします。</p>
<p>さて、これで今度はcargo buildでのコンパイルが通るはずです。
さっきと同様に、Open OCDとGDBを立ち上げてプログラムを実行すると、Open OCD側にHello Worldが出現するのが期待される結果ですが、そのためにはOpen OCDのセミホスティング機能を有効化する必要があります。
GDBを立ち上げ<code>target remote :3333</code>を実行したあとに、</p>
<pre><code>(gdb) monitor arm semihosting enable
</code></pre>
<p>というコマンドを実行してから、<code>continue</code>を実行してプログラムを再開すると、以下のようにOpen OCD側にHello Worldが出力されるはずです。</p>
<pre><code>...
xPSR: 0x01000000 pc: 0x08000008 msp: 0x2001c000
in procedure 'arm'
semihosting is enabled
Hello World

</code></pre>
<h1><a class="header" href="#割り込み制御" id="割り込み制御">割り込み制御</a></h1>
<p>割り込みはOSをつくる上で重要な項目の1つです。
ペリフェラルが割り込み信号を送ることで、OSは現在の実行処理を中断してペリフェラルからの処理をすることができます。</p>
<p>Armでは現在の実行を中断して非同期に発生するイベントを「例外処理」と呼んでいて、割り込みもその１つです。
今回はSysTickというArmに内蔵されているタイマーモジュールを例として扱ってみようと思います。
SysTickはシステムタイマーといわれていて、OSで一定周期ごとに行う処理などを実装するモジュールです。
このモジュールはARMv7-Mでは必須のモジュールであるため、今回使うNucleoのボード以外のARMv7-Mのボードでも存在するはずです。</p>
<h2><a class="header" href="#armv7-mの例外モデル" id="armv7-mの例外モデル">ARMv7-Mの例外モデル</a></h2>
<p>ARMv7-MのリファレンスマニュアルB1.5章に例外処理の詳細が書かれています。
例外が発生すると、前の章で説明したVector Tableに従って処理が決定されます。
割り込みを含む例外が発生すると、例外に割り振られたIDによってVector Tableに書かれたアドレスにジャンプします。
今回扱うSysTickモジュールではB1.5.2章によると15番の例外が発生します。つまり、Vector Tableの15番目のエントリーとして呼びたい関数をおいておくことになります。</p>
<p>例外が発生した際、後にもとのプログラムの実行に戻るため、プロセッサの状態を一部保存する必要があります。具体的にはArmのレジスタをメモリに退避させることになります。
ここでArmのレジスタについて簡単に説明します。詳しくはB1.4章に書かれています。
ARMv7-MではR0からR15までのレジスタが使用可能です。R0からR12レジスタが汎用レジスタと呼ばれるもので、プログラム中で自由に使うことができます。
R13からR15も算術命令などで使うこともできるのですが、それぞれ特殊な意味を持つレジスタになっています。
R13がスタックポインタ（SP）になっています。現在のスタック領域のメモリアドレスを指すものです。モードによって実は２つのスタックポインタレジスタが使い分けられています。
つまり、プロセッサのモードによって一見アセンブラ命令上は同じSPでも異なるSPを指すことがあるということです。詳しくは次の章で説明します。
R14はリンクレジスタ（LR）です。これは関数の呼び出しをおこなった場合に使われるもので、その関数呼び出しから戻る先のアドレスを保存するためのレジスタです。
R15はプログラムカウンタ（PC)で、現在、実行中の命令のメモリアドレスが格納されているレジスタです。
これ以外のレジスタとしていくつかシステムレジスタが存在しています。これは通常の算術命令などではアクセスできず、特別な命令でしかアクセスできません。
そのうちの１つがプログラムスタータスレジスタ（PSR）というものです。このレジスタは32ビットのレジスタなのですが、用途に合わせて3つのレジスタに分解されるというものです。詳細はここでは割愛します。</p>
<p>例外が発生するとき、ハードウェアがシステムの状態を自動的にスタック領域に退避してくれます。B1.5.6章を見てみましょう。
スタックにはPSR、例外処理が完了したあとに戻るべきアドレス、LR（R14）、R12、R3からR0までが退避されます。また、浮動小数点拡張が有効になっている場合、さらに浮動小数点に関するレジスタも退避されますが、今回は有効にしていないので気にしなくても大丈夫です。
例外処理から復帰する際、これらのスタックに保存されたものが自動的にレジスタに書き戻され、スタックポインタの位置も戻される、という処理もなされます。
しかし、スタック領域に保存されない汎用レジスタが存在することに注意が必要です。これらは通常のプログラムで使用される可能性が十分にあります。
スタックポインタは通常の関数呼び出しをして戻ってくる際に元の値に戻されるはずなので問題ないでしょう。
プログラムカウンタも完了したあと戻るべきアドレスがスタック上に保存されていて、それがプログラムカウンタに書き戻されるのでこれも大丈夫です。
残りのR4からR11のレジスタが使われる可能性があります。しかし、これらのレジスタはArmの関数の呼び出し規約により、関数を呼び出しても関数側で値を戻す必要があるのでこれも保存しなくても大丈夫です。
よって、割り込みハンドラとして関数を呼び出して戻るだけなら、ハードウェア側で必要なレジスタはすべてスタックに保存される、ということになります。</p>
<p>割り込みハンドラ関数から通常の処理に復帰する際にはPCに通常のアドレスではなく、特殊な値を書き戻すことによって通常モードに戻ることができます。
これがB1.5.8で説明されていることです。しかし、B1.5.6章を見ると、割り込みが発生する際、LRの値がもとのモードに戻るように設定されることがわかります。
つまり、特に何もしなくても通常の処理に戻れそうです。</p>
<h2><a class="header" href="#systickの割り込みハンドラを定義する" id="systickの割り込みハンドラを定義する">SysTickの割り込みハンドラを定義する</a></h2>
<p>では、SysTickの割り込みハンドラを定義しましょう。今回は割り込みハンドラの中で特に特別なことはせず、適当な文字列をセミホスティングで表示させるだけにしましょう。
Embedonomiconの4章にあるコードを<code>main.rs</code>に貼り付けてそのまま使ってしまいましょう。</p>
<pre><code>pub union Vector {
    reserved: u32,
    handler: unsafe extern &quot;C&quot; fn(),
}

extern &quot;C&quot; {
    fn NMI();
    fn HardFault();
    fn MemManage();
    fn BusFault();
    fn UsageFault();
    fn SVCall();
    fn PendSV();
    fn SysTick();
}

#[link_section = &quot;.vector_table.exceptions&quot;]
#[no_mangle]
pub static EXCEPTIONS: [Vector; 14] = [
    Vector { handler: NMI },
    Vector { handler: HardFault },
    Vector { handler: MemManage },
    Vector { handler: BusFault },
    Vector {
        handler: UsageFault,
    },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { handler: SVCall },
    Vector { reserved: 0 },
    Vector { reserved: 0 },
    Vector { handler: PendSV },
    Vector { handler: SysTick },
];

#[no_mangle]
pub extern &quot;C&quot; fn DefaultExceptionHandler() {
    loop {}
}
</code></pre>
<p><code>extern C</code>によってSysTick関数やそれ以外の例外ハンドル用の関数を宣言しています。
これはC言語などで書かれた関数を呼び出すものです。よって、リンクする際にどこかから引っ張ってこなければなりません。
そのため、Embedonomiconでは以下のようなセクションをリンカスクリプトに加えています。</p>
<pre><code>PROVIDE(NMI = DefaultExceptionHandler);
PROVIDE(HardFault = DefaultExceptionHandler);
PROVIDE(MemManage = DefaultExceptionHandler);
PROVIDE(BusFault = DefaultExceptionHandler);
PROVIDE(UsageFault = DefaultExceptionHandler);
PROVIDE(SVCall = DefaultExceptionHandler);
PROVIDE(PendSV = DefaultExceptionHandler);
PROVIDE(SysTick = DefaultExceptionHandler);
</code></pre>
<p>これは、該当する関数が見つからなかった場合、<code>DefaultExceptionHandler</code>を代わりに使うという文になっています。
さらに、<code>EXCEPTIONS</code>を<code>RESET_VECTOR</code>直後に置くため、<code>.vector_table</code>セクションも以下のように書き換える必要があります。</p>
<pre><code>  .vector_table ORIGIN(FLASH) :
  {
    LONG(ORIGIN(RAM) + LENGTH(RAM));

    KEEP(*(.vector_table.reset_vector));

    KEEP(*(.vector_table.exceptions));
  } &gt; FLASH
</code></pre>
<p>これで、とりあえず、ビルドは通りますが、実行しても<code>SysTick</code>関数を定義していないので、ただの無限ループである<code>DefaultExceptionHandler</code>を使うだけなのでなにもわかりません。
そのうえ、まだSysTick割り込みを発生させるためのSysTickモジュールの設定もしていないので、これも行う必要があります。</p>
<p>それではまず、SysTick関数を定義しておきましょう。この関数はあとでリンカスクリプトから参照され、割り込みが発生したときC言語の関数呼び出しのように呼ばれるので、
<code>DefaultExceptionHandler</code>と同様に<code>no_mangle</code>と<code>extern &quot;C&quot;</code>をつけておく必要がある点に注意しましょう。</p>
<pre><code>#[no_mangle]
pub extern &quot;C&quot; fn SysTick() {
    hprintln!(&quot;Systick&quot;).unwrap();
}
</code></pre>
<p>この関数を定義したあと、先程加えた<code>extern &quot;C&quot;</code>で各種例外ハンドル用関数を宣言していたところから<code>SysTick</code>の部分を取り除く必要もあります。</p>
<h2><a class="header" href="#systickモジュールを定義する" id="systickモジュールを定義する">SysTickモジュールを定義する</a></h2>
<p>SysTickの例外ハンドラが定義できたところで、実際のSysTick例外を発生させるところにチャレンジしましょう。
ところで、今まですべての関数をすべて<code>main.rs</code>に書いてきてしまいました。Embedonmiconではいくつかのサブプロジェクトにわけてクレートとして分離する、という方法をとってコードを整理しています。
同じようにクレートとして分離するのも悪くないのですが、今回はお手軽にモジュールという形で分離しましょう。
詳しくは<a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">TPRLの7章</a>が参考になると思います。
このモジュールのシステムは2018 Editionで大きく変更がされているため、いくつかのブログは2015 Editionをベースにしてある場合があることに注意が必要です。
ただし、後方互換性はあるので、2015 Editionに沿った方法でモジュールを分割しても大きな問題にはなりません。</p>
<p><code>src</code>ディレクトリ以下に<code>systick.rs</code>という以下のような関数を含んだファイルをつくりましょう。</p>
<pre><code>use cortex_m_semihosting::hprintln;

pub fn init() {
    hprintln!(&quot;Systick init&quot;).unwrap();
}
</code></pre>
<p>続いて、<code>main.rs</code>内の<code>Reset</code>関数を以下のように書き換えます。
<code>systick</code>モジュールの宣言と、<code>systick</code>モジュール内の<code>init</code>関数を呼び出しています。</p>
<pre><code>mod systick;

#[no_mangle]
pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    extern &quot;C&quot; {
        static mut _sbss: u8;
        static mut _ebss: u8;
        static mut _sidata: u8;
        static mut _sdata: u8;
        static mut _edata: u8;
    }

    let count = &amp;_ebss as *const u8 as usize - &amp;_sbss as *const u8 as usize;
    ptr::write_bytes(&amp;mut _sbss as *mut u8, 0, count);

    let count = &amp;_edata as *const u8 as usize - &amp;_sdata as *const u8 as usize;
    ptr::copy_nonoverlapping(&amp;_sidata as *const u8, &amp;mut _sdata as *mut u8, count);

    hprintln!(&quot;Hello World&quot;).unwrap();

    systick::init();

    loop {}
}
</code></pre>
<p>ここまでで一度ビルドして実行すると新たに<code>Systick init</code>という文字列が表示されるはずです。
ここからSysTickに関係するコードはこの<code>systick.rs</code>内に書いていき、<code>systick</code>モジュールとして<code>main.rs</code>から使いましょう。</p>
<h2><a class="header" href="#systickのレジスタを設定する" id="systickのレジスタを設定する">SysTickのレジスタを設定する</a></h2>
<p>SysTickを制御するにはSysTickのレジスタを叩いてあげる必要があります。
ArmではこのようなモジュールやペリフェラルのレジスタをメモリマップドIOという形で読み書きします。
プログラム側からは普通のメモリアクセスと同じようにできるという点で便利な仕組みです。
メモリマップドIOとは、このような外部のデバイスのレジスタをメモリアドレスに割り当てて、メモリアクセスのようにレジスタを読み書きする仕組みです。
ただし、これらのレジスタの値の読み書きは本物のメモリとは違って例えば、一部のビットが書き込み不可であるアドレスに書き込んだあとすぐに読み込んだら値が一致しないとか、何も書き込んでいないのに時間が立つと値が変わっている、などの現象が発生します。
そのため、コンパイラが普通のメモリアクセスと同じような最適化をかけてしまうと正しく動作しない場合があります。ここには注意しましょう。</p>
<p>SysTickの詳しい説明はリファレンスマニュアルのB3.3章にまとまっています。
SysTickを使うにはコントロールレジスタ（CSR）、リロードバリューレジスタ（RVR）、カレントバリューレジスタ（CVR）、キャリブレーションバリューレジスタ（CALIB)の3つを触ることになります。
CSRはこのSysTickを有効化させたり、割り込み発生をさせるかどうかの制御などをするためのものです。
CVRは現在のタイマーの値で時間経過とともに値が減っていきます。この値が0になると割り込みを発生させることができます。
0になったあとはRVRで設定された値になります。つまり、RVRの値が割り込みの周期ということになります。
さて、このCVRがどのくらい時間で値が減っていくかですが、CALIBレジスタにその値が記されています。
CALIBには10ミリ秒ごとにどの程度値が減るかの値が設定されるリードオンリーレジスタです。この下位24ビットの値を見てあげれば、RVRやCVRを適切に設定できます。
これらのレジスタがどこにマップされているかもこのリファレンスマニュアルのB3.3.2章に書かれています。</p>
<p>さて、あとはこれらのレジスタを使うだけです。これらのメモリアドレスにアクセスするには標準ライブラリの<code>core::ptr</code>内にある<a href="https://doc.rust-lang.org/core/ptr/fn.read_volatile.html"><code>read_volatile</code></a>と<a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html"><code>write_volatile</code></a>を使います。
volatileというのは揮発性のという意味で、C言語などでは変数の修飾子としてつけることで、その変数へのアクセスの最適化をさせないようにすることができます。
同様に<code>read_volatile</code>や<code>write_volatile</code>も最適化によって変更されてほしくないアクセス、つまり今回のようなメモリマップドIOに使える関数です。
今回は1秒毎に割り込みが発生するように設定してみましょう。<code>systick.rs</code>内の<code>init</code>関数を以下のように書き換えましょう。</p>
<pre><code>use cortex_m_semihosting::hprintln;
use core::ptr::{read_volatile, write_volatile};

const CSR_ADDR: usize = 0xE000_E010;
const RVR_ADDR: usize = 0xE000_E014;
const CVR_ADDR: usize = 0xE000_E018;
const CALIB_ADDR: usize = 0xE000_E01C;

pub fn init() {
    hprintln!(&quot;Systick init&quot;).unwrap();
    unsafe {
        write_volatile(CVR_ADDR as *mut u32, 0);
        let calib_val = read_volatile(CALIB_ADDR as *const u32) &amp; 0x00FF_FFFF;
        write_volatile(RVR_ADDR as *mut u32, calib_val * 100);
        write_volatile(CSR_ADDR as *mut u32, 0x3);
    }
}
</code></pre>
<p><code>read_volative</code>及び<code>write_volatile</code>はともに<code>unsafe</code>な関数なので<code>unsafe</code>ブロックで囲う必要があります。
なお、アドレスを渡す際に<code>usize</code>型をポインタにキャストしている部分がありますが、この操作自体はRustでは安全とされています。
ただし、このアドレスをいざ読み書きする段階になると、この先にあるアドレスがちゃんとしたものになっているかの保証もないですし、ライフタイムのチェックもないので<code>unsafe</code>となるわけです。</p>
<p>さて、これでコンパイルすると、今までのメッセージに加えてSysTickハンドラが1秒毎に呼び出されてメッセージが表示されているはずです。
また、デバッガで動作を止めると、<code>Reset</code>関数自体は最後の無限ループで止まっているのがわかります。</p>
<h1><a class="header" href="#プロセス切り替え" id="プロセス切り替え">プロセス切り替え</a></h1>
<p>この章ではOSの要となるプロセスの切り替えを実装します。</p>
<p>そもそもプロセスとは、実行中のプログラムのことで、OSの中では各プロセスの状態というものを保存することで自由に実行を中断したり実行を再開させるということができます。
このプロセスの状態というものをプログラムの中で定義してあげて、適切に保存するロジックを実装する、というのがこの章のテーマです。
今まではただのOSなしでのプログラミング、すなわちベアメタルプログラミングと大した違いはなかったのですが、プロセス切り替えを実現できるとだいぶ雰囲気が変わってくると思います。</p>
<h2><a class="header" href="#armv7-mのcpuモードについて" id="armv7-mのcpuモードについて">ARMv7-MのCPUモードについて</a></h2>
<p>OSは一章でも少し説明したように通常のアプリケーションとは異なるCPUのモードで動くことが多いです。
一般にアプリケーション用のCPUモードだとシステムレジスタへのアクセスが制限されたり、使うレジスタが異なる場合や、一部のメモリにアクセスできなかったりします。
このCPUモードの切り替えによって、アプリケーションが他のアプリケーションに影響を与えたり、OSの機能を乗っ取ることを防止しているわけです。</p>
<p>Cortex-Mは他のアーキテクチャのCPUモードと比べると境目がかなり曖昧で制限も弱いですが、一応ちゃんと存在しています。4章でもちらっと登場しました。
ここでしっかり見てみましょう。</p>
<p>ARMv7-MのB1.3章を見てみましょう。ARMv7-Mではモード、特権、使用するスタックポインタを切り替えることができ、これらがシステムレベルのアーキテクチャを把握するのに重要なキーとなります。
順番に見ていきましょう。
まず、モードですが、スレッドモードとハンドラモードの2種類があります。リセット直後だとスレッドモードとなり、このモードが通常のプログラムが実行されている状態と考えることができるでしょう。
例外が発生するとハンドラモードに移行します。このモードに突入し例外処理が終わったあと、例外復帰処理をすることでまたスレッドモードに移行できます。
例外復帰処理とは4章でちょこっと説明しましたが、ARMv7-MではLRを特殊な値にセットすることで実現されます。このときのLRの値によってモードや後述する特権や使用するスタックポインタの切り替えもできます。
ここで注意したいのが、スレッドモードもハンドラモードも１章で言及した「カーネルモード」と対応するものではないということです。このモードの違いは権限を分けるためのものではないからです。</p>
<p>プログラムの権限を調整するのが特権です。特権状態と非特権状態が存在します。特権状態でないと実行できない命令が存在します。
ハンドラモードでは常に特権状態になりますが、スレッドモードでは非特権状態になることが可能です。
OSが実行するときはプロセッサの機能がすべて使えるように特権モードになるべきで、そうでない通常のアプリケーションの場合は非特権モードを使うのがよさそうですね。</p>
<p>ARMv7-Mではスタックポインタが２種類存在して使い分けることができる、ということは４章でもちらっと言いましたが、ここでちゃんと見てみましょう。
スタックポインタにはメインとプロセスの２種類存在していて、前述したモードや特権とは独立したパラメータとして設定することができます。
ただし、ハンドラモードでは常にメインが使われることになります。</p>
<p>ここで１つ補足しておくと、
汎用OSが動くようなCPUだと通常、メモリ管理ユニット（MMU）というものが備わっていて、OSと通常のアプリケーションでアクセスできるメモリ領域を制限したり、
アプリケーション間で異なる物理メモリを同一のアドレスに割り当てるアドレス変換といったことができるのですが、残念ながらARMv7-MにはMMUは備わっていません。
一応、メモリ保護機構（MPU）というものは備わっていて、これを使うことでアプリケーションがアクセスできるメモリ領域を制限することはできるのですが、本書では扱いません。</p>
<h2><a class="header" href="#cpuの状態を切り替える" id="cpuの状態を切り替える">CPUの状態を切り替える</a></h2>
<p>それでは、実際にどのようにプロセスというものを実現するかを考えていきましょう。
各プロセスはスレッドモードで、OSに干渉しないように非特権状態で、またスタックポインタもプロセスを使うようにしましょう。
OSは今までどおりスレッドモード・特権状態・スタックポインタはメインを使うようにしましょう。</p>
<p>状態切り替えの方法としては一度Supervisor call例外（SVCall例外）を発生させてハンドラモードに入って、そのリターン時に切り替えるというのがいいでしょう。
このSVCall例外は<code>svc</code>というソフトウェアの命令で発生させることのできるもので、アプリケーションからOSの機能を呼び出すシステムコールを実装する際に使うものです。
この例外ハンドラの処理として、OSから発生した場合はプロセスに、プロセスから発生した場合はOSに戻る、という処理を実装しましょう。
SVCall例外が発生したとき、<code>SVCall</code>という関数を呼び出すように４章ですでにベクターテーブルを設定していたので、この関数を実装しましょう。
<code>SysTick</code>のときと同じように<code>extern &quot;C&quot;</code>で宣言しているところから<code>SVCall</code>を消す必要もあります。</p>
<pre><code>#[no_mangle]
pub unsafe extern &quot;C&quot; fn SVCall() {
    asm!(
        &quot;
        cmp lr, #0xfffffff9
        bne to_kernel

        mov r0, #1
        msr CONTROL, r0
        movw lr, #0xfffd
        movt lr, #0xffff
        bx lr
    
        to_kernel:
        mov r0, #0
        msr CONTROL, r0

        movw lr, #0xfff9
        movt lr, #0xffff
        bx lr
        &quot;
    ::::&quot;volatile&quot;);
}
</code></pre>
<p>さて、いきなり<code>asm!</code>というものが現れました。これはインラインアセンブラと呼ばれるもので、アセンブラ命令を直接埋め込むための記法です。
ただし、この記法はstableのコンパイラではサポートされておらず、このままコンパイルするとエラーが出てしまいます。
このようにstableでサポートされていない機能を用いるには、以下のような宣言を追加する必要があります。</p>
<pre><code>#![feature(asm)]
</code></pre>
<p>これをmain.rsの冒頭に置いておきましょう。これでとりあえずコンパイルは通るようになるはずです。
なぜ今回アセンブラ命令を直接使ったかというと、LRやシステムレジスタに直接アクセスする必要があったからです。
本来、直接アセンブラ命令を書くことはあまり褒められた行為ではないです。
まず、Rustならではの型のチェックやライフタイムの判定などができなくなりミスをしやすくなり、また、アーキテクチャ間での移植性も低くなってしまいます。
ですが、今回のようなケースだとなんかしらの形でアセンブラを直接書かざるを得ないので、今回はインラインアセンブラを使っています。</p>
<p>アセンブラの中身ですが、<code>cmp</code>というのが比較命令で、リンクレジスタの中身を見てあげることでカーネルから来たのかアプリケーションから来たのかを判定しています。
<code>bne</code>は直前の比較命令で等しくない場合にラベルまでジャンプするという命令です。
<code>msr</code>というのがシステムレジスタに値を書き込む命令です。<code>CONTROL</code>レジスタに1を書き込むことで非特権状態にすることができます。
<code>movw</code>と<code>movt</code>命令でリンクレジスタの値を書き換えることで、使うスタックを切り替え、<code>bx</code>命令で例外復帰している、というような流れです。
アセンブラの詳細についてはリファレンスマニュアルのA4章を参照するか、ネットで検索してもわかりやすい資料が結構あると思います。</p>
<p>さて、<code>svc</code>命令でアプリケーション用の状態にしていきたいところですが、その前に、アプリケーション用のスタックポインタの初期値を決める必要があります。
さらに、<code>SVCall</code>関数で例外復帰する際にスタックポインタに保存されたレジスタの値を実際のレジスタに書き戻すという処理がなされます。
そのためアプリケーション用のスタックにアプリケーションの初期状態の値を格納しないといけません。
では、まずスタック上にどのようにレジスタの値が保存されるかをちゃんと見てみましょう。
前回の章でも紹介したリファレンスマニュアルのB1.5.7章に書かれています。
スタックポインタにコンテキストステートフレームという形で8ワード（レジスタ8つ分）のデータが割り込みが発生すると保存されることが説明されています。
これを予め設定してあげます。一つ注意点ですが、このスタックは通常は8バイトにアラインされていないといけない、つまりアドレスが8の倍数になっていなければならない点です。
ここに気をつけてまずはスタック用のメモリ領域を確保するところからはじめましょう。
通常のプログラムであれば、mallocなどでの動的メモリ確保の命令でメモリ領域を確保するのですが、mallocはOSのないベアメタルプログラムでは使えないです。
そこでメモリ領域の一部を割り当てるように新しいセクションをリンカスクリプトで定義して、それをスタックとして使いましょう。</p>
<p>まず、リンカスクリプトに以下のように新しいブロックを足します。</p>
<pre><code>...
  _sidata = LOADADDR(.data);

  .app_stack ALIGN(0x08):
  {
    *(.app_stack .app_stack.*);
  } &gt; RAM


  /DISCARD/ :
...
</code></pre>
<p>このセクションに新しいstatic変数を配置してあげましょう。static変数というのはプログラム実行中ずっと生き残り続ける変数です。</p>
<pre><code>    #[link_section = &quot;.app_stack&quot;]
    static mut APP_STACK: [u8; 1024] = [0; 1024];
</code></pre>
<p>0で初期化しているように見えますが、実際はbssセクションのように0初期化するプログラムを書いていないので、この配列の初期値は不定です。しかし、スタック領域は0初期化する必要がないので問題がありません。
このメモリ領域の末尾8ワードに初期状態を格納するのですが、その前にわかりやすいように、コンテキストフレーム用の構造体を定義してあげましょう。
そうすれば、後々の作業が楽になります。
まず、これを新しいモジュール上に実装するため、<code>process.rs</code>という新しいファイルをつくり、その中に、以下のような構造体を宣言します。</p>
<pre><code>#[repr(C)]
pub struct ContextFrame {
    pub r0: u32,
    pub r1: u32,
    pub r2: u32,
    pub r3: u32,
    pub r12: u32,
    pub lr: u32,
    pub return_addr: u32,
    pub xpsr: u32,
}
</code></pre>
<p><code>repr(C)</code>というアトリビュートがついています。これは通常のRustの構造体だと実際にどのように各メンバーがメモリ上に配置されるかという保証がないためつける必要があります。
詳しくは<a href="https://doc.rust-lang.org/nomicon/data.html">Rustonomiconの2章のデータレイアウトに関する章</a>を参考にしてください。</p>
<p>では、先程確保したスタック領域の末尾8ワードを<code>ContextFame</code>型として取り出すコードを書いてみましょう。</p>
<pre><code>mod process;
use process::ContextFrame;

...
    let ptr = (&amp;APP_STACK[0] as *const u8 as usize) + 1024 - 0x20;
    let context_freame: &amp;mut ContextFrame = &amp;mut *(ptr as *mut ContextFrame);
...
</code></pre>
<p>ポインタを参照に変換する処理はunsafeです。Reset関数内に書いているのであれば、Reset関数そのものがunsafeなのでunsafeブロックで囲う必要はないですが、それ以外の普通の関数としてくくりだしているときはunsafeブロックで囲ってあげましょう。</p>
<p>初期値ですが、汎用レジスタは0で初期化すればよさそうです。LRの値も使われないので特に指定する必要はありません。
<code>return_addr</code>はプログラムカウンタに書き戻される値になります。よってこの値はアプリケーションとして実行したいプログラムのアドレスにすればいいです。
<code>xPSR</code>の値ですが、各ビットの詳細の説明はリファレンスマニュアルのB1.4.2に各ビットが何を示しているかが書いてあります。
結論から言うと、EPSRに含まれる24ビットのTフィールドのみを1にすればいいです。このTというのはプログラムの命令フォーマットを示しています。
このArmというアーキテクチャには実は2つの命令フォーマットが存在していて、プログラムのアドレスの下位1ビットを使ってそれを切り替える、という仕様がじつはあります。
リファレンスマニュアルのA4.1章に詳細が書かれています。ArmにはARM命令セットとThumb命令セットという2つの命令セットがあり、これらを混在させることができます。
しかし、ARMv7-MではThumb命令しかサポートしていません。<code>BX</code>などの命令でプログラムカウンタに値を書き込む際、最下位ビットの値が1ならばThumb命令として解釈されます。
しかし、この例外復帰時のスタックからプログラムカウンタに書き戻される処理はこの命令セット切り替え処理はされず、最下位ビットは無視されます。
なので、<code>return_addr</code>に対して何かをする必要はないです。</p>
<p>とりあえず、プロセスから呼び出す関数を定義しておきましょう。適当な文字列を出力して、svc命令によってカーネル側に復帰するコードにしましょう。</p>
<pre><code>extern &quot;C&quot; fn app_main() -&gt; ! {
    hprintln!(&quot;App&quot;).unwrap();
    unsafe { asm!(&quot;svc 0&quot;::::&quot;volatile&quot;); }
    loop {}
}
</code></pre>
<p>この関数を使い以下のようようなコードを書けば、初期領域ができます。</p>
<pre><code>    context_freame.r0 = 0;
    context_freame.r1 = 0;
    context_freame.r2 = 0;
    context_freame.r3 = 0;
    context_freame.r12 = 0;
    context_freame.lr = 0;
    context_freame.return_addr = app_main as u32;
    context_freame.xpsr = 0x0100_0000;
</code></pre>
<p>あとは、<code>svc</code>命令を呼び出して上げましょう。プロセススタックポインタの値を初期化するのもあわせて行う必要があります。</p>
<pre><code>    asm!(
        &quot;
        msr psp, r0
        svc 0
        &quot;
        ::&quot;{r0}&quot;(ptr):&quot;r4&quot;, &quot;r5&quot;, &quot;r6&quot;, &quot;r7&quot;, &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r11&quot;:&quot;volatile&quot;);
</code></pre>
<p>3つ目のコロンに続くところにr4などのレジスタが列挙されていますが、これはこのアセンブラ命令中に変更される可能性があるレジスタです。
このように書いておけば、コンパイルするときにこれらのレジスタが変更されることを考慮したコードが出力されます。
4章でも触れましたが、例外が発生したときにこれらのレジスタはスタックに保存されないため、これらはきちんと保存しなければなりません。</p>
<p>さて、ここまでできればあとはビルドして実行するだけです。
以下のような出力がOpenOCDから出てくるはずです。</p>
<pre><code>Hello World
Systick init
App
Kernel
Systick
Systick
...
</code></pre>
<h1><a class="header" href="#スケジューラを実装する" id="スケジューラを実装する">スケジューラを実装する</a></h1>
<p>前回の章でアプリケーションプロセスへの切り替えを実装しました。
しかし、現状だと再びアプリケーションに突入したり、複数のアプリケーションを動かしたり、といったことができていません。
この章では、簡単なラウンドロビン型のスケジューラを実装して複数のアプリケーションを動かすことを目標としましょう。</p>
<p>TBD</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
